/*
Rundeck / Runbook Automation API

Rundeck / Runbook Automation REST API for job automation, execution management, and system administration

API version: 56
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"reflect"
	"strings"
)

// AuthorizationAPIService AuthorizationAPI service
type AuthorizationAPIService service

type ApiAppContextAuthorizationsForResourceKindRequest struct {
	ctx        context.Context
	ApiService *AuthorizationAPIService
	kind       string
	actions    *[]string
}

// Actions to check authorization for
func (r ApiAppContextAuthorizationsForResourceKindRequest) Actions(actions []string) ApiAppContextAuthorizationsForResourceKindRequest {
	r.actions = &actions
	return r
}

func (r ApiAppContextAuthorizationsForResourceKindRequest) Execute() (*AuthorizationsResponse, *http.Response, error) {
	return r.ApiService.AppContextAuthorizationsForResourceKindExecute(r)
}

/*
AppContextAuthorizationsForResourceKind Check authorization for application resource kind

Evaluates whether the current user has authorization to perform specific actions on resources of a given kind within the application context.

This endpoint checks permissions for a resource type (kind) such as "job", "project", "system", etc., and returns authorization results for each requested action. The evaluation is performed using the application's access control policies and the authenticated user's permissions.

Useful for UI components that need to conditionally display features or for applications that need to verify permissions before attempting operations.

**INCUBATING**: This endpoint is in "incubating" status, and may change.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param kind Resource Kind
	@return ApiAppContextAuthorizationsForResourceKindRequest
*/
func (a *AuthorizationAPIService) AppContextAuthorizationsForResourceKind(ctx context.Context, kind string) ApiAppContextAuthorizationsForResourceKindRequest {
	return ApiAppContextAuthorizationsForResourceKindRequest{
		ApiService: a,
		ctx:        ctx,
		kind:       kind,
	}
}

// Execute executes the request
//
//	@return AuthorizationsResponse
func (a *AuthorizationAPIService) AppContextAuthorizationsForResourceKindExecute(r ApiAppContextAuthorizationsForResourceKindRequest) (*AuthorizationsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AuthorizationsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthorizationAPIService.AppContextAuthorizationsForResourceKind")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/authorizations/application/{kind}"
	localVarPath = strings.Replace(localVarPath, "{"+"kind"+"}", url.PathEscape(parameterValueToString(r.kind, "kind")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.actions == nil {
		return localVarReturnValue, nil, reportError("actions is required and must be specified")
	}

	{
		t := *r.actions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "actions", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "actions", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["rundeckApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Rundeck-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppContextAuthorizationsForTypeWithSpecifierRequest struct {
	ctx        context.Context
	ApiService *AuthorizationAPIService
	type_      string
	specifier  string
	actions    *[]string
}

// Actions to check authorization for
func (r ApiAppContextAuthorizationsForTypeWithSpecifierRequest) Actions(actions []string) ApiAppContextAuthorizationsForTypeWithSpecifierRequest {
	r.actions = &actions
	return r
}

func (r ApiAppContextAuthorizationsForTypeWithSpecifierRequest) Execute() (*AuthorizationsResponse, *http.Response, error) {
	return r.ApiService.AppContextAuthorizationsForTypeWithSpecifierExecute(r)
}

/*
AppContextAuthorizationsForTypeWithSpecifier Get authorizations for an application type with specifier

Get authorizations for the supplied set of actions for the subject executing the API call.
Evaluation is made in the context of the application for the supplied type and specifier.

**INCUBATING**: This endpoint is in "incubating" status, and may change.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param type_ Resource Type
	@param specifier Resource specifier
	@return ApiAppContextAuthorizationsForTypeWithSpecifierRequest
*/
func (a *AuthorizationAPIService) AppContextAuthorizationsForTypeWithSpecifier(ctx context.Context, type_ string, specifier string) ApiAppContextAuthorizationsForTypeWithSpecifierRequest {
	return ApiAppContextAuthorizationsForTypeWithSpecifierRequest{
		ApiService: a,
		ctx:        ctx,
		type_:      type_,
		specifier:  specifier,
	}
}

// Execute executes the request
//
//	@return AuthorizationsResponse
func (a *AuthorizationAPIService) AppContextAuthorizationsForTypeWithSpecifierExecute(r ApiAppContextAuthorizationsForTypeWithSpecifierRequest) (*AuthorizationsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AuthorizationsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthorizationAPIService.AppContextAuthorizationsForTypeWithSpecifier")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/authorizations/application/{type}/{specifier}"
	localVarPath = strings.Replace(localVarPath, "{"+"type"+"}", url.PathEscape(parameterValueToString(r.type_, "type_")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"specifier"+"}", url.PathEscape(parameterValueToString(r.specifier, "specifier")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.actions == nil {
		return localVarReturnValue, nil, reportError("actions is required and must be specified")
	}

	{
		t := *r.actions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "actions", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "actions", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["rundeckApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Rundeck-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProjectContextAuthorizationsForJobRequest struct {
	ctx        context.Context
	ApiService *AuthorizationAPIService
	project    string
	specifier  string
	actions    *[]string
}

// Actions to check authorization for
func (r ApiProjectContextAuthorizationsForJobRequest) Actions(actions []string) ApiProjectContextAuthorizationsForJobRequest {
	r.actions = &actions
	return r
}

func (r ApiProjectContextAuthorizationsForJobRequest) Execute() (*AuthorizationsResponse, *http.Response, error) {
	return r.ApiService.ProjectContextAuthorizationsForJobExecute(r)
}

/*
ProjectContextAuthorizationsForJob Get authorizations for a job

Get authorizations for the supplied set of actions for the subject executing the API call.
Evaluation is made in the context of the project for the supplied job.

**INCUBATING**: This endpoint is in "incubating" status, and may change.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param project Project Name
	@param specifier Job Id
	@return ApiProjectContextAuthorizationsForJobRequest
*/
func (a *AuthorizationAPIService) ProjectContextAuthorizationsForJob(ctx context.Context, project string, specifier string) ApiProjectContextAuthorizationsForJobRequest {
	return ApiProjectContextAuthorizationsForJobRequest{
		ApiService: a,
		ctx:        ctx,
		project:    project,
		specifier:  specifier,
	}
}

// Execute executes the request
//
//	@return AuthorizationsResponse
func (a *AuthorizationAPIService) ProjectContextAuthorizationsForJobExecute(r ApiProjectContextAuthorizationsForJobRequest) (*AuthorizationsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AuthorizationsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthorizationAPIService.ProjectContextAuthorizationsForJob")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/authorizations/project/{project}/job/{specifier}"
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"specifier"+"}", url.PathEscape(parameterValueToString(r.specifier, "specifier")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.actions == nil {
		return localVarReturnValue, nil, reportError("actions is required and must be specified")
	}

	{
		t := *r.actions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "actions", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "actions", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["rundeckApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Rundeck-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProjectContextAuthorizationsForResourceKindRequest struct {
	ctx        context.Context
	ApiService *AuthorizationAPIService
	project    string
	kind       string
	actions    *[]string
}

// Actions to check authorization for
func (r ApiProjectContextAuthorizationsForResourceKindRequest) Actions(actions []string) ApiProjectContextAuthorizationsForResourceKindRequest {
	r.actions = &actions
	return r
}

func (r ApiProjectContextAuthorizationsForResourceKindRequest) Execute() (*AuthorizationsResponse, *http.Response, error) {
	return r.ApiService.ProjectContextAuthorizationsForResourceKindExecute(r)
}

/*
ProjectContextAuthorizationsForResourceKind Get authorizations for a project resource kind

Get authorizations for the supplied set of actions for the subject executing the API call.
Evaluation is made in the context of the project for the supplied resource kind.

**INCUBATING**: This endpoint is in "incubating" status, and may change.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param project Project Name
	@param kind Resource Kind
	@return ApiProjectContextAuthorizationsForResourceKindRequest
*/
func (a *AuthorizationAPIService) ProjectContextAuthorizationsForResourceKind(ctx context.Context, project string, kind string) ApiProjectContextAuthorizationsForResourceKindRequest {
	return ApiProjectContextAuthorizationsForResourceKindRequest{
		ApiService: a,
		ctx:        ctx,
		project:    project,
		kind:       kind,
	}
}

// Execute executes the request
//
//	@return AuthorizationsResponse
func (a *AuthorizationAPIService) ProjectContextAuthorizationsForResourceKindExecute(r ApiProjectContextAuthorizationsForResourceKindRequest) (*AuthorizationsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AuthorizationsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthorizationAPIService.ProjectContextAuthorizationsForResourceKind")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/authorizations/project/{project}/{kind}"
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"kind"+"}", url.PathEscape(parameterValueToString(r.kind, "kind")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.actions == nil {
		return localVarReturnValue, nil, reportError("actions is required and must be specified")
	}

	{
		t := *r.actions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "actions", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "actions", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["rundeckApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Rundeck-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProjectContextAuthorizationsForTypeWithSpecifierRequest struct {
	ctx        context.Context
	ApiService *AuthorizationAPIService
	project    string
	type_      string
	specifier  string
	actions    *[]string
}

// Actions to check authorization for
func (r ApiProjectContextAuthorizationsForTypeWithSpecifierRequest) Actions(actions []string) ApiProjectContextAuthorizationsForTypeWithSpecifierRequest {
	r.actions = &actions
	return r
}

func (r ApiProjectContextAuthorizationsForTypeWithSpecifierRequest) Execute() (*AuthorizationsResponse, *http.Response, error) {
	return r.ApiService.ProjectContextAuthorizationsForTypeWithSpecifierExecute(r)
}

/*
ProjectContextAuthorizationsForTypeWithSpecifier Get authorizations for a type with specifier

Get authorizations for the supplied set of actions for the subject executing the API call.
Evaluation is made in the context of the project for the type with a specifier.

**INCUBATING**: This endpoint is in "incubating" status, and may change.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param project Project Name
	@param type_ Resource Type
	@param specifier Resource specifier
	@return ApiProjectContextAuthorizationsForTypeWithSpecifierRequest
*/
func (a *AuthorizationAPIService) ProjectContextAuthorizationsForTypeWithSpecifier(ctx context.Context, project string, type_ string, specifier string) ApiProjectContextAuthorizationsForTypeWithSpecifierRequest {
	return ApiProjectContextAuthorizationsForTypeWithSpecifierRequest{
		ApiService: a,
		ctx:        ctx,
		project:    project,
		type_:      type_,
		specifier:  specifier,
	}
}

// Execute executes the request
//
//	@return AuthorizationsResponse
func (a *AuthorizationAPIService) ProjectContextAuthorizationsForTypeWithSpecifierExecute(r ApiProjectContextAuthorizationsForTypeWithSpecifierRequest) (*AuthorizationsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AuthorizationsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthorizationAPIService.ProjectContextAuthorizationsForTypeWithSpecifier")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/authorizations/project/{project}/{type}/{specifier}"
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"type"+"}", url.PathEscape(parameterValueToString(r.type_, "type_")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"specifier"+"}", url.PathEscape(parameterValueToString(r.specifier, "specifier")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.actions == nil {
		return localVarReturnValue, nil, reportError("actions is required and must be specified")
	}

	{
		t := *r.actions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "actions", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "actions", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["rundeckApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Rundeck-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
