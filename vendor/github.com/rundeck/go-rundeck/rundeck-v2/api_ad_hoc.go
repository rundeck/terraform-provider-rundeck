/*
Rundeck / Runbook Automation API

Rundeck / Runbook Automation REST API for job automation, execution management, and system administration

API version: 56
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// AdHocAPIService AdHocAPI service
type AdHocAPIService service

type ApiApiRunCommandv14Request struct {
	ctx                context.Context
	ApiService         *AdHocAPIService
	project            string
	filter             *string
	exec               *string
	nodeThreadcount    *int32
	nodeKeepgoing      *bool
	asUser             *string
	apiRunAdhocRequest *ApiRunAdhocRequest
}

// Node Filter String
func (r ApiApiRunCommandv14Request) Filter(filter string) ApiApiRunCommandv14Request {
	r.filter = &filter
	return r
}

// The shell command string to run, e.g. \&quot;echo hello\&quot;.
func (r ApiApiRunCommandv14Request) Exec(exec string) ApiApiRunCommandv14Request {
	r.exec = &exec
	return r
}

// threadcount to use
func (r ApiApiRunCommandv14Request) NodeThreadcount(nodeThreadcount int32) ApiApiRunCommandv14Request {
	r.nodeThreadcount = &nodeThreadcount
	return r
}

// if \&quot;true\&quot;, continue executing on other nodes even if some fail.
func (r ApiApiRunCommandv14Request) NodeKeepgoing(nodeKeepgoing bool) ApiApiRunCommandv14Request {
	r.nodeKeepgoing = &nodeKeepgoing
	return r
}

// specifies a username identifying the user who ran the command. Requires &#x60;runAs&#x60; permission.
func (r ApiApiRunCommandv14Request) AsUser(asUser string) ApiApiRunCommandv14Request {
	r.asUser = &asUser
	return r
}

// Request body
func (r ApiApiRunCommandv14Request) ApiRunAdhocRequest(apiRunAdhocRequest ApiRunAdhocRequest) ApiApiRunCommandv14Request {
	r.apiRunAdhocRequest = &apiRunAdhocRequest
	return r
}

func (r ApiApiRunCommandv14Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ApiRunCommandv14Execute(r)
}

/*
ApiRunCommandv14 Run Adhoc Command

Run a command string.

Authorization required: `run` for project resource type `adhoc`, as well as `runAs` if the runAs parameter is used

Since: v14

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param project Project Name
	@return ApiApiRunCommandv14Request
*/
func (a *AdHocAPIService) ApiRunCommandv14(ctx context.Context, project string) ApiApiRunCommandv14Request {
	return ApiApiRunCommandv14Request{
		ApiService: a,
		ctx:        ctx,
		project:    project,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *AdHocAPIService) ApiRunCommandv14Execute(r ApiApiRunCommandv14Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AdHocAPIService.ApiRunCommandv14")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project/{project}/run/command"
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "form", "")
	}
	if r.exec != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exec", r.exec, "form", "")
	}
	if r.nodeThreadcount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nodeThreadcount", r.nodeThreadcount, "form", "")
	}
	if r.nodeKeepgoing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nodeKeepgoing", r.nodeKeepgoing, "form", "")
	}
	if r.asUser != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "asUser", r.asUser, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.apiRunAdhocRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["rundeckApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Rundeck-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiRunScriptUrlv14Request struct {
	ctx                    context.Context
	ApiService             *AdHocAPIService
	project                string
	filter                 *string
	argString              *string
	scriptURL              *string
	nodeThreadcount        *int32
	nodeKeepgoing          *bool
	asUser                 *string
	scriptInterpreter      *string
	fileExtension          *string
	interpreterArgsQuoted  *bool
	apiRunScriptv14Request *ApiRunScriptv14Request
}

// Node Filter String
func (r ApiApiRunScriptUrlv14Request) Filter(filter string) ApiApiRunScriptUrlv14Request {
	r.filter = &filter
	return r
}

// Arguments to pass to the script when executed
func (r ApiApiRunScriptUrlv14Request) ArgString(argString string) ApiApiRunScriptUrlv14Request {
	r.argString = &argString
	return r
}

// A URL pointing to a script file
func (r ApiApiRunScriptUrlv14Request) ScriptURL(scriptURL string) ApiApiRunScriptUrlv14Request {
	r.scriptURL = &scriptURL
	return r
}

// threadcount to use
func (r ApiApiRunScriptUrlv14Request) NodeThreadcount(nodeThreadcount int32) ApiApiRunScriptUrlv14Request {
	r.nodeThreadcount = &nodeThreadcount
	return r
}

// if \&quot;true\&quot;, continue executing on other nodes even if some fail.
func (r ApiApiRunScriptUrlv14Request) NodeKeepgoing(nodeKeepgoing bool) ApiApiRunScriptUrlv14Request {
	r.nodeKeepgoing = &nodeKeepgoing
	return r
}

// specifies a username identifying the user who ran the command. Requires &#x60;runAs&#x60; permission.
func (r ApiApiRunScriptUrlv14Request) AsUser(asUser string) ApiApiRunScriptUrlv14Request {
	r.asUser = &asUser
	return r
}

// a command to use to run the script
func (r ApiApiRunScriptUrlv14Request) ScriptInterpreter(scriptInterpreter string) ApiApiRunScriptUrlv14Request {
	r.scriptInterpreter = &scriptInterpreter
	return r
}

// extension of the script file on the remote node (since v14)
func (r ApiApiRunScriptUrlv14Request) FileExtension(fileExtension string) ApiApiRunScriptUrlv14Request {
	r.fileExtension = &fileExtension
	return r
}

// if true, the script file and arguments will be quoted as the last argument to the &#x60;scriptInterpreter&#x60;
func (r ApiApiRunScriptUrlv14Request) InterpreterArgsQuoted(interpreterArgsQuoted bool) ApiApiRunScriptUrlv14Request {
	r.interpreterArgsQuoted = &interpreterArgsQuoted
	return r
}

// Adhoc Script URL Request
func (r ApiApiRunScriptUrlv14Request) ApiRunScriptv14Request(apiRunScriptv14Request ApiRunScriptv14Request) ApiApiRunScriptUrlv14Request {
	r.apiRunScriptv14Request = &apiRunScriptv14Request
	return r
}

func (r ApiApiRunScriptUrlv14Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ApiRunScriptUrlv14Execute(r)
}

/*
ApiRunScriptUrlv14 Run Adhoc Script URL

Run a script downloaded from a URL.

Authorization required: `run` for project resource type `adhoc`, as well as `runAs` if the runAs parameter is used

Since: v14

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param project Project Name
	@return ApiApiRunScriptUrlv14Request
*/
func (a *AdHocAPIService) ApiRunScriptUrlv14(ctx context.Context, project string) ApiApiRunScriptUrlv14Request {
	return ApiApiRunScriptUrlv14Request{
		ApiService: a,
		ctx:        ctx,
		project:    project,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *AdHocAPIService) ApiRunScriptUrlv14Execute(r ApiApiRunScriptUrlv14Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AdHocAPIService.ApiRunScriptUrlv14")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project/{project}/run/url"
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "form", "")
	}
	if r.argString != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "argString", r.argString, "form", "")
	}
	if r.scriptURL != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scriptURL", r.scriptURL, "form", "")
	}
	if r.nodeThreadcount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nodeThreadcount", r.nodeThreadcount, "form", "")
	}
	if r.nodeKeepgoing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nodeKeepgoing", r.nodeKeepgoing, "form", "")
	}
	if r.asUser != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "asUser", r.asUser, "form", "")
	}
	if r.scriptInterpreter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scriptInterpreter", r.scriptInterpreter, "form", "")
	}
	if r.fileExtension != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fileExtension", r.fileExtension, "form", "")
	}
	if r.interpreterArgsQuoted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "interpreterArgsQuoted", r.interpreterArgsQuoted, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.apiRunScriptv14Request
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["rundeckApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Rundeck-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiRunScriptv14Request struct {
	ctx                   context.Context
	ApiService            *AdHocAPIService
	project               string
	filter                *string
	argString             *string
	nodeThreadcount       *int32
	nodeKeepgoing         *bool
	asUser                *string
	scriptInterpreter     *string
	fileExtension         *string
	interpreterArgsQuoted *bool
	runAdhocRequest       *ApiRunAdhocRequest
}

// Node Filter String
func (r ApiApiRunScriptv14Request) Filter(filter string) ApiApiRunScriptv14Request {
	r.filter = &filter
	return r
}

// Arguments to pass to the script when executed
func (r ApiApiRunScriptv14Request) ArgString(argString string) ApiApiRunScriptv14Request {
	r.argString = &argString
	return r
}

// threadcount to use
func (r ApiApiRunScriptv14Request) NodeThreadcount(nodeThreadcount int32) ApiApiRunScriptv14Request {
	r.nodeThreadcount = &nodeThreadcount
	return r
}

// if \&quot;true\&quot;, continue executing on other nodes even if some fail.
func (r ApiApiRunScriptv14Request) NodeKeepgoing(nodeKeepgoing bool) ApiApiRunScriptv14Request {
	r.nodeKeepgoing = &nodeKeepgoing
	return r
}

// specifies a username identifying the user who ran the command. Requires &#x60;runAs&#x60; permission.
func (r ApiApiRunScriptv14Request) AsUser(asUser string) ApiApiRunScriptv14Request {
	r.asUser = &asUser
	return r
}

// a command to use to run the script
func (r ApiApiRunScriptv14Request) ScriptInterpreter(scriptInterpreter string) ApiApiRunScriptv14Request {
	r.scriptInterpreter = &scriptInterpreter
	return r
}

// extension of the script file on the remote node (since v14)
func (r ApiApiRunScriptv14Request) FileExtension(fileExtension string) ApiApiRunScriptv14Request {
	r.fileExtension = &fileExtension
	return r
}

// if true, the script file and arguments will be quoted as the last argument to the &#x60;scriptInterpreter&#x60;
func (r ApiApiRunScriptv14Request) InterpreterArgsQuoted(interpreterArgsQuoted bool) ApiApiRunScriptv14Request {
	r.interpreterArgsQuoted = &interpreterArgsQuoted
	return r
}

func (r ApiApiRunScriptv14Request) RunAdhocRequest(runAdhocRequest ApiRunAdhocRequest) ApiApiRunScriptv14Request {
	r.runAdhocRequest = &runAdhocRequest
	return r
}

func (r ApiApiRunScriptv14Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ApiRunScriptv14Execute(r)
}

/*
ApiRunScriptv14 Run Adhoc Script

Run a script.

Authorization required: `run` for project resource type `adhoc`, as well as `runAs` if the runAs parameter is used

Since: v14

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param project Project Name
	@return ApiApiRunScriptv14Request
*/
func (a *AdHocAPIService) ApiRunScriptv14(ctx context.Context, project string) ApiApiRunScriptv14Request {
	return ApiApiRunScriptv14Request{
		ApiService: a,
		ctx:        ctx,
		project:    project,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *AdHocAPIService) ApiRunScriptv14Execute(r ApiApiRunScriptv14Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AdHocAPIService.ApiRunScriptv14")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project/{project}/run/script"
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "form", "")
	}
	if r.argString != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "argString", r.argString, "form", "")
	}
	if r.nodeThreadcount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nodeThreadcount", r.nodeThreadcount, "form", "")
	}
	if r.nodeKeepgoing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nodeKeepgoing", r.nodeKeepgoing, "form", "")
	}
	if r.asUser != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "asUser", r.asUser, "form", "")
	}
	if r.scriptInterpreter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scriptInterpreter", r.scriptInterpreter, "form", "")
	}
	if r.fileExtension != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fileExtension", r.fileExtension, "form", "")
	}
	if r.interpreterArgsQuoted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "interpreterArgsQuoted", r.interpreterArgsQuoted, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data", "application/x-www-form-urlencoded", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.runAdhocRequest != nil {
		paramJson, err := parameterToJson(*r.runAdhocRequest)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("runAdhocRequest", paramJson)
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["rundeckApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Rundeck-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
