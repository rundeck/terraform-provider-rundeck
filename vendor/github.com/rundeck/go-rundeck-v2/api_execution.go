/*
Rundeck

Rundeck provides a Web API for use with your applications.

API version: 53
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// ExecutionAPIService ExecutionAPI service
type ExecutionAPIService service

type ApiApiExecutionRequest struct {
	ctx context.Context
	ApiService *ExecutionAPIService
	id string
}

func (r ApiApiExecutionRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiExecutionExecute(r)
}

/*
ApiExecution Execution Info

Get the status for an execution by ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Execution ID
 @return ApiApiExecutionRequest
*/
func (a *ExecutionAPIService) ApiExecution(ctx context.Context, id string) ApiApiExecutionRequest {
	return ApiApiExecutionRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *ExecutionAPIService) ApiExecutionExecute(r ApiApiExecutionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionAPIService.ApiExecution")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/execution/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["rundeckApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Rundeck-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiExecutionAbortRequest struct {
	ctx context.Context
	ApiService *ExecutionAPIService
	id string
	asUser *string
	forceIncomplete *bool
}

// Specifies a username identifying the user who aborted the execution. Requires &#x60;runAs&#x60; actiion authorization.
func (r ApiApiExecutionAbortRequest) AsUser(asUser string) ApiApiExecutionAbortRequest {
	r.asUser = &asUser
	return r
}

// if &#x60;true&#x60;, forces a running execution to be marked as \&quot;incomplete\&quot;.
func (r ApiApiExecutionAbortRequest) ForceIncomplete(forceIncomplete bool) ApiApiExecutionAbortRequest {
	r.forceIncomplete = &forceIncomplete
	return r
}

func (r ApiApiExecutionAbortRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiExecutionAbortExecute(r)
}

/*
ApiExecutionAbort Aborting Executions

Abort a running execution by ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Execution ID
 @return ApiApiExecutionAbortRequest
*/
func (a *ExecutionAPIService) ApiExecutionAbort(ctx context.Context, id string) ApiApiExecutionAbortRequest {
	return ApiApiExecutionAbortRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *ExecutionAPIService) ApiExecutionAbortExecute(r ApiApiExecutionAbortRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionAPIService.ApiExecutionAbort")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/execution/{id}/abort"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.asUser != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "asUser", r.asUser, "form", "")
	}
	if r.forceIncomplete != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "forceIncomplete", r.forceIncomplete, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["rundeckApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Rundeck-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiExecutionDeleteRequest struct {
	ctx context.Context
	ApiService *ExecutionAPIService
	id string
}

func (r ApiApiExecutionDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiExecutionDeleteExecute(r)
}

/*
ApiExecutionDelete Delete an Execution

Delete an execution by ID.

Authorization requirement: Requires the `delete_execution` action allowed for a `project` in the `application` context.

See: [Administration - Access Control Policy - Application Scope Resources and Actions](https://docs.rundeck.com/docs/administration/security/authorization.html#application-scope-resources-and-actions)



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Execution ID
 @return ApiApiExecutionDeleteRequest
*/
func (a *ExecutionAPIService) ApiExecutionDelete(ctx context.Context, id string) ApiApiExecutionDeleteRequest {
	return ApiApiExecutionDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *ExecutionAPIService) ApiExecutionDeleteExecute(r ApiApiExecutionDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionAPIService.ApiExecutionDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/execution/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["rundeckApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Rundeck-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiExecutionDeleteBulkRequest struct {
	ctx context.Context
	ApiService *ExecutionAPIService
	ids *string
	apiExecutionDeleteBulkRequest *ApiExecutionDeleteBulkRequest
}

// comma separated list of IDs
func (r ApiApiExecutionDeleteBulkRequest) Ids(ids string) ApiApiExecutionDeleteBulkRequest {
	r.ids = &ids
	return r
}

// Delete Bulk IDs request.
func (r ApiApiExecutionDeleteBulkRequest) ApiExecutionDeleteBulkRequest(apiExecutionDeleteBulkRequest ApiExecutionDeleteBulkRequest) ApiApiExecutionDeleteBulkRequest {
	r.apiExecutionDeleteBulkRequest = &apiExecutionDeleteBulkRequest
	return r
}

func (r ApiApiExecutionDeleteBulkRequest) Execute() (*DeleteBulkResponse, *http.Response, error) {
	return r.ApiService.ApiExecutionDeleteBulkExecute(r)
}

/*
ApiExecutionDeleteBulk Bulk Delete Executions

Delete a set of Executions by their IDs.

The IDs can be specified in two ways:

1. Using a URL parameter `ids`, as a comma separated list, with no body content

        POST /api/12/executions/delete?ids=1,2,17
        Content-Length: 0

2. Using a request body of JSON data.

Note: the JSON schema also supports a basic JSON array 


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiExecutionDeleteBulkRequest
*/
func (a *ExecutionAPIService) ApiExecutionDeleteBulk(ctx context.Context) ApiApiExecutionDeleteBulkRequest {
	return ApiApiExecutionDeleteBulkRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DeleteBulkResponse
func (a *ExecutionAPIService) ApiExecutionDeleteBulkExecute(r ApiApiExecutionDeleteBulkRequest) (*DeleteBulkResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeleteBulkResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionAPIService.ApiExecutionDeleteBulk")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/executions/delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ids", r.ids, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.apiExecutionDeleteBulkRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["rundeckApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Rundeck-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiExecutionInputFilesRequest struct {
	ctx context.Context
	ApiService *ExecutionAPIService
	id string
}

func (r ApiApiExecutionInputFilesRequest) Execute() (*ExecutionFileInfoList, *http.Response, error) {
	return r.ApiService.ApiExecutionInputFilesExecute(r)
}

/*
ApiExecutionInputFiles List Input Files for an Execution

List input files used for an execution. Since: V19

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Execution ID
 @return ApiApiExecutionInputFilesRequest
*/
func (a *ExecutionAPIService) ApiExecutionInputFiles(ctx context.Context, id string) ApiApiExecutionInputFilesRequest {
	return ApiApiExecutionInputFilesRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ExecutionFileInfoList
func (a *ExecutionAPIService) ApiExecutionInputFilesExecute(r ApiApiExecutionInputFilesRequest) (*ExecutionFileInfoList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExecutionFileInfoList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionAPIService.ApiExecutionInputFiles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/execution/{id}/input/files"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["rundeckApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Rundeck-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiExecutionMetricsDocsRequest struct {
	ctx context.Context
	ApiService *ExecutionAPIService
	project *string
	statusFilter *string
	abortedbyFilter *string
	jobIdListFilter *string
	excludeJobIdListFilter *string
	jobListFilter *string
	excludeJobListFilter *string
	groupPath *string
	groupPathExact *string
	excludeGroupPath *string
	excludeGroupPathExact *string
	jobFilter *string
	excludeJobFilter *string
	jobExactFilter *string
	excludeJobExactFilter *string
	startafterFilter *string
	startbeforeFilter *string
	endafterFilter *string
	endbeforeFilter *string
	begin *string
	end *string
	adhoc *bool
	recentFilter *string
	olderFilter *string
	userFilter *string
	executionTypeFilter *string
	max *int32
	offset *int32
}

// Project name
func (r ApiApiExecutionMetricsDocsRequest) Project(project string) ApiApiExecutionMetricsDocsRequest {
	r.project = &project
	return r
}

// Execution status
func (r ApiApiExecutionMetricsDocsRequest) StatusFilter(statusFilter string) ApiApiExecutionMetricsDocsRequest {
	r.statusFilter = &statusFilter
	return r
}

// Username who aborted an execution
func (r ApiApiExecutionMetricsDocsRequest) AbortedbyFilter(abortedbyFilter string) ApiApiExecutionMetricsDocsRequest {
	r.abortedbyFilter = &abortedbyFilter
	return r
}

// specify a Job ID to include, can be specified multiple times
func (r ApiApiExecutionMetricsDocsRequest) JobIdListFilter(jobIdListFilter string) ApiApiExecutionMetricsDocsRequest {
	r.jobIdListFilter = &jobIdListFilter
	return r
}

// specify a Job ID to exclude, can be specified multiple times
func (r ApiApiExecutionMetricsDocsRequest) ExcludeJobIdListFilter(excludeJobIdListFilter string) ApiApiExecutionMetricsDocsRequest {
	r.excludeJobIdListFilter = &excludeJobIdListFilter
	return r
}

// specify a full Job group/name to include, can be specified multiple times
func (r ApiApiExecutionMetricsDocsRequest) JobListFilter(jobListFilter string) ApiApiExecutionMetricsDocsRequest {
	r.jobListFilter = &jobListFilter
	return r
}

// specify a full Job group/name to exclude, can be specified multiple times
func (r ApiApiExecutionMetricsDocsRequest) ExcludeJobListFilter(excludeJobListFilter string) ApiApiExecutionMetricsDocsRequest {
	r.excludeJobListFilter = &excludeJobListFilter
	return r
}

// specify a group or partial group path to include all jobs within that group path. Set to the special value \&quot;-\&quot; to match the top level jobs only.
func (r ApiApiExecutionMetricsDocsRequest) GroupPath(groupPath string) ApiApiExecutionMetricsDocsRequest {
	r.groupPath = &groupPath
	return r
}

// specify an exact group path to match.  Set to the special value \&quot;-\&quot; to match the top level jobs only.
func (r ApiApiExecutionMetricsDocsRequest) GroupPathExact(groupPathExact string) ApiApiExecutionMetricsDocsRequest {
	r.groupPathExact = &groupPathExact
	return r
}

// specify a group or partial group path to exclude all jobs within that group path. Set to the special value \&quot;-\&quot; to match the top level jobs only.
func (r ApiApiExecutionMetricsDocsRequest) ExcludeGroupPath(excludeGroupPath string) ApiApiExecutionMetricsDocsRequest {
	r.excludeGroupPath = &excludeGroupPath
	return r
}

// specify an exact group path to exclude.  Set to the special value \&quot;-\&quot; to match the top level jobs only.
func (r ApiApiExecutionMetricsDocsRequest) ExcludeGroupPathExact(excludeGroupPathExact string) ApiApiExecutionMetricsDocsRequest {
	r.excludeGroupPathExact = &excludeGroupPathExact
	return r
}

// specify a filter for the job Name. Include any job name that matches this value
func (r ApiApiExecutionMetricsDocsRequest) JobFilter(jobFilter string) ApiApiExecutionMetricsDocsRequest {
	r.jobFilter = &jobFilter
	return r
}

// specify a filter for the job Name. Exclude any job name that matches this value.
func (r ApiApiExecutionMetricsDocsRequest) ExcludeJobFilter(excludeJobFilter string) ApiApiExecutionMetricsDocsRequest {
	r.excludeJobFilter = &excludeJobFilter
	return r
}

// specify an exact job name to match.
func (r ApiApiExecutionMetricsDocsRequest) JobExactFilter(jobExactFilter string) ApiApiExecutionMetricsDocsRequest {
	r.jobExactFilter = &jobExactFilter
	return r
}

// specify an exact job name to exclude.
func (r ApiApiExecutionMetricsDocsRequest) ExcludeJobExactFilter(excludeJobExactFilter string) ApiApiExecutionMetricsDocsRequest {
	r.excludeJobExactFilter = &excludeJobExactFilter
	return r
}

// start after date
func (r ApiApiExecutionMetricsDocsRequest) StartafterFilter(startafterFilter string) ApiApiExecutionMetricsDocsRequest {
	r.startafterFilter = &startafterFilter
	return r
}

// start before date
func (r ApiApiExecutionMetricsDocsRequest) StartbeforeFilter(startbeforeFilter string) ApiApiExecutionMetricsDocsRequest {
	r.startbeforeFilter = &startbeforeFilter
	return r
}

// end after date
func (r ApiApiExecutionMetricsDocsRequest) EndafterFilter(endafterFilter string) ApiApiExecutionMetricsDocsRequest {
	r.endafterFilter = &endafterFilter
	return r
}

// end before date
func (r ApiApiExecutionMetricsDocsRequest) EndbeforeFilter(endbeforeFilter string) ApiApiExecutionMetricsDocsRequest {
	r.endbeforeFilter = &endbeforeFilter
	return r
}

// Specify exact date for earliest execution completion time. Format: a unix millisecond timestamp, or a W3C dateTime string in the format \&quot;yyyy-MM-ddTHH:mm:ssZ\&quot;.
func (r ApiApiExecutionMetricsDocsRequest) Begin(begin string) ApiApiExecutionMetricsDocsRequest {
	r.begin = &begin
	return r
}

// Specify exact date for latest execution completion time. Format: a unix millisecond timestamp, or a W3C dateTime string in the format \&quot;yyyy-MM-ddTHH:mm:ssZ\&quot;.
func (r ApiApiExecutionMetricsDocsRequest) End(end string) ApiApiExecutionMetricsDocsRequest {
	r.end = &end
	return r
}

// if true, include only Adhoc executions, if false return only Job executions. By default any matching executions are returned, however if you use any of the Job filters below, then only Job executions will be returned.
func (r ApiApiExecutionMetricsDocsRequest) Adhoc(adhoc bool) ApiApiExecutionMetricsDocsRequest {
	r.adhoc = &adhoc
	return r
}

// Use a simple text format to filter executions that completed within a period of time. The format is \&quot;XY\&quot; where X is an integer, and \&quot;Y\&quot; is one of: * &#x60;s&#x60;: second * &#x60;n&#x60;: minute * &#x60;h&#x60;: hour * &#x60;d&#x60;: day * &#x60;w&#x60;: week * &#x60;m&#x60;: month * &#x60;y&#x60;: year  So a value of &#x60;2w&#x60; would return executions that completed within the last two weeks. 
func (r ApiApiExecutionMetricsDocsRequest) RecentFilter(recentFilter string) ApiApiExecutionMetricsDocsRequest {
	r.recentFilter = &recentFilter
	return r
}

// (same format as &#x60;recentFilter&#x60;) return executions that completed before the specified relative period of time.  E.g. a value of &#x60;30d&#x60; returns executions older than 30 days.
func (r ApiApiExecutionMetricsDocsRequest) OlderFilter(olderFilter string) ApiApiExecutionMetricsDocsRequest {
	r.olderFilter = &olderFilter
	return r
}

// Username who started the execution
func (r ApiApiExecutionMetricsDocsRequest) UserFilter(userFilter string) ApiApiExecutionMetricsDocsRequest {
	r.userFilter = &userFilter
	return r
}

// specify the execution type, one of: &#x60;scheduled&#x60; (schedule trigger), &#x60;user&#x60; (user trigger), &#x60;user-scheduled&#x60; (user scheduled trigger). Since: v20
func (r ApiApiExecutionMetricsDocsRequest) ExecutionTypeFilter(executionTypeFilter string) ApiApiExecutionMetricsDocsRequest {
	r.executionTypeFilter = &executionTypeFilter
	return r
}

// maximum number of results to include in response. (default: 20)
func (r ApiApiExecutionMetricsDocsRequest) Max(max int32) ApiApiExecutionMetricsDocsRequest {
	r.max = &max
	return r
}

// offset for first result to include. (default: 0)
func (r ApiApiExecutionMetricsDocsRequest) Offset(offset int32) ApiApiExecutionMetricsDocsRequest {
	r.offset = &offset
	return r
}

func (r ApiApiExecutionMetricsDocsRequest) Execute() (*MetricsQueryResponse, *http.Response, error) {
	return r.ApiService.ApiExecutionMetricsDocsExecute(r)
}

/*
ApiExecutionMetricsDocs Execution Query Metrics

Obtain metrics over the result set of an execution query.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiExecutionMetricsDocsRequest
*/
func (a *ExecutionAPIService) ApiExecutionMetricsDocs(ctx context.Context) ApiApiExecutionMetricsDocsRequest {
	return ApiApiExecutionMetricsDocsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MetricsQueryResponse
func (a *ExecutionAPIService) ApiExecutionMetricsDocsExecute(r ApiApiExecutionMetricsDocsRequest) (*MetricsQueryResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MetricsQueryResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionAPIService.ApiExecutionMetricsDocs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/executions/metrics"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.project != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "project", r.project, "form", "")
	}
	if r.statusFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "statusFilter", r.statusFilter, "form", "")
	}
	if r.abortedbyFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "abortedbyFilter", r.abortedbyFilter, "form", "")
	}
	if r.jobIdListFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "jobIdListFilter", r.jobIdListFilter, "form", "")
	}
	if r.excludeJobIdListFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludeJobIdListFilter", r.excludeJobIdListFilter, "form", "")
	}
	if r.jobListFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "jobListFilter", r.jobListFilter, "form", "")
	}
	if r.excludeJobListFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludeJobListFilter", r.excludeJobListFilter, "form", "")
	}
	if r.groupPath != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "groupPath", r.groupPath, "form", "")
	}
	if r.groupPathExact != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "groupPathExact", r.groupPathExact, "form", "")
	}
	if r.excludeGroupPath != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludeGroupPath", r.excludeGroupPath, "form", "")
	}
	if r.excludeGroupPathExact != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludeGroupPathExact", r.excludeGroupPathExact, "form", "")
	}
	if r.jobFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "jobFilter", r.jobFilter, "form", "")
	}
	if r.excludeJobFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludeJobFilter", r.excludeJobFilter, "form", "")
	}
	if r.jobExactFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "jobExactFilter", r.jobExactFilter, "form", "")
	}
	if r.excludeJobExactFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludeJobExactFilter", r.excludeJobExactFilter, "form", "")
	}
	if r.startafterFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startafterFilter", r.startafterFilter, "form", "")
	}
	if r.startbeforeFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startbeforeFilter", r.startbeforeFilter, "form", "")
	}
	if r.endafterFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endafterFilter", r.endafterFilter, "form", "")
	}
	if r.endbeforeFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endbeforeFilter", r.endbeforeFilter, "form", "")
	}
	if r.begin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "begin", r.begin, "form", "")
	}
	if r.end != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "form", "")
	}
	if r.adhoc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adhoc", r.adhoc, "form", "")
	}
	if r.recentFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recentFilter", r.recentFilter, "form", "")
	}
	if r.olderFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "olderFilter", r.olderFilter, "form", "")
	}
	if r.userFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userFilter", r.userFilter, "form", "")
	}
	if r.executionTypeFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "executionTypeFilter", r.executionTypeFilter, "form", "")
	}
	if r.max != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max", r.max, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["rundeckApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Rundeck-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiExecutionMetricsProjectDocsRequest struct {
	ctx context.Context
	ApiService *ExecutionAPIService
	project string
}

func (r ApiApiExecutionMetricsProjectDocsRequest) Execute() (*MetricsQueryResponse, *http.Response, error) {
	return r.ApiService.ApiExecutionMetricsProjectDocsExecute(r)
}

/*
ApiExecutionMetricsProjectDocs Execution Query Metrics

Obtain metrics over the result set of an execution query over the executions of a single project.

Note: This endpoint has the same query parameters and response as the `/executions/metrics` endpoint.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param project Project name
 @return ApiApiExecutionMetricsProjectDocsRequest
*/
func (a *ExecutionAPIService) ApiExecutionMetricsProjectDocs(ctx context.Context, project string) ApiApiExecutionMetricsProjectDocsRequest {
	return ApiApiExecutionMetricsProjectDocsRequest{
		ApiService: a,
		ctx: ctx,
		project: project,
	}
}

// Execute executes the request
//  @return MetricsQueryResponse
func (a *ExecutionAPIService) ApiExecutionMetricsProjectDocsExecute(r ApiApiExecutionMetricsProjectDocsRequest) (*MetricsQueryResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MetricsQueryResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionAPIService.ApiExecutionMetricsProjectDocs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project/{project}/executions/metrics"
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["rundeckApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Rundeck-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiExecutionMetricsProjectDocs_0Request struct {
	ctx context.Context
	ApiService *ExecutionAPIService
	project string
}

func (r ApiApiExecutionMetricsProjectDocs_0Request) Execute() (*MetricsQueryResponse, *http.Response, error) {
	return r.ApiService.ApiExecutionMetricsProjectDocs_1Execute(r)
}

/*
ApiExecutionMetricsProjectDocs_0 Execution Query Metrics

Obtain metrics over the result set of an execution query over the executions of a single project.

Note: This endpoint has the same query parameters and response as the `/executions/metrics` endpoint.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param project Project name
 @return ApiApiExecutionMetricsProjectDocs_0Request
*/
func (a *ExecutionAPIService) ApiExecutionMetricsProjectDocs_1(ctx context.Context, project string) ApiApiExecutionMetricsProjectDocs_0Request {
	return ApiApiExecutionMetricsProjectDocs_0Request{
		ApiService: a,
		ctx: ctx,
		project: project,
	}
}

// Execute executes the request
//  @return MetricsQueryResponse
func (a *ExecutionAPIService) ApiExecutionMetricsProjectDocs_1Execute(r ApiApiExecutionMetricsProjectDocs_0Request) (*MetricsQueryResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MetricsQueryResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionAPIService.ApiExecutionMetricsProjectDocs_1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project/{project}/executions/metrics"
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["rundeckApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Rundeck-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiExecutionOutputRequest struct {
	ctx context.Context
	ApiService *ExecutionAPIService
	id string
	nodename *string
	stepctx *string
	offset *int32
	lastlines *int32
	lastmod *int64
	maxlines *int32
	compacted *bool
	format *string
}

// Node Name, all results will be filtered for only this node.
func (r ApiApiExecutionOutputRequest) Nodename(nodename string) ApiApiExecutionOutputRequest {
	r.nodename = &nodename
	return r
}

// Step Context ID. This is a string in the form &#x60;1/2/3&#x60; indicating the step context.
func (r ApiApiExecutionOutputRequest) Stepctx(stepctx string) ApiApiExecutionOutputRequest {
	r.stepctx = &stepctx
	return r
}

// byte offset to read from in the file. 0 indicates the beginning.
func (r ApiApiExecutionOutputRequest) Offset(offset int32) ApiApiExecutionOutputRequest {
	r.offset = &offset
	return r
}

// number of lines to retrieve from the end of the available output. If specified it will override the &#x60;offset&#x60; value and return only the specified number of lines at the end of the log.
func (r ApiApiExecutionOutputRequest) Lastlines(lastlines int32) ApiApiExecutionOutputRequest {
	r.lastlines = &lastlines
	return r
}

// epoch datestamp in milliseconds, return results only if modification changed since the specified date OR if more data is available at the given &#x60;offset&#x60;.
func (r ApiApiExecutionOutputRequest) Lastmod(lastmod int64) ApiApiExecutionOutputRequest {
	r.lastmod = &lastmod
	return r
}

// maximum number of lines to retrieve forward from the specified offset.
func (r ApiApiExecutionOutputRequest) Maxlines(maxlines int32) ApiApiExecutionOutputRequest {
	r.maxlines = &maxlines
	return r
}

// if true, results will be in compacted form. Since: v21
func (r ApiApiExecutionOutputRequest) Compacted(compacted bool) ApiApiExecutionOutputRequest {
	r.compacted = &compacted
	return r
}

// Specify output format
func (r ApiApiExecutionOutputRequest) Format(format string) ApiApiExecutionOutputRequest {
	r.format = &format
	return r
}

func (r ApiApiExecutionOutputRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ApiExecutionOutputExecute(r)
}

/*
ApiExecutionOutput Execution Output

Get the output for an execution by ID. The execution can be currently running or may have already completed. Output can be filtered down to a specific node or workflow step.

The log output for each execution is stored in a file on the Rundeck server, and this API endpoint allows you to retrieve some or all of the output, in several possible formats: json, and plain text. When retrieving the plain text output, some metadata about the log is included in HTTP Headers. JSON includes metadata about each output log line, as well as metadata about the state of the execution and log file, and your current index location in the file.

Output can be selected by Node or Step Context or both as of API v10.

Several parameters can be used to retrieve only part of the output log data. You can use these parameters to more efficiently retrieve the log content over time while an execution is running.

The log file used to store the execution output is a formatted text file which also contains metadata about each line of log output emitted during an execution. Several data values in this API endpoint refer to "bytes", but these do not reflect the size of the final log data; they are only relative to the formatted log file itself. You can treat these byte values as opaque locations in the log file, but you should not try to correlate them to the actual textual log lines.

#### Tailing Output

To "tail" the output from a running execution, you will need to make a series of requests to this API endpoint, and update the `offset` value that you send to reflect the returned `dataoffset` value that you receive.  This gives you a consistent pointer into the output log file.

When starting these requests, there are two mechanisms you can use:

1. Start at the beginning, specifying either a `lastmod` or a `offset` of 0
2. Start at the end, by using `lastlines` to receive the last available set of log lines.

After your first request you will have the `dataoffset` and `lastmod` response values you can use to continue making requests for subsequent log output. You can choose several ways to do this:

1. Use the `offset` and `lastmod` parameters to indicate modification time and receive as much output as is available
2. Use the `offset` and `maxlines` parameter to specify a maximum number of log entries
3. Use only the `offset` parameter and receive as much output as is available.

After each request, you will update your `offset` value to reflect the `dataoffset` in the response.

All log output has been read when the `iscompleted` value is "true".

Below is some example pseudo-code for using this API endpoint to follow the output of a running execution "live":

* set offset to 0
* set lastmod to 0
* Repeat until `iscompleted` response value is "true":
    * perform request sending `offset` and `lastmod` parameters
    * print any log entries, update progress bar, etc.
    * Record the resulting `dataoffset` and `lastmod` response values for the next request
    * if `unmodified` is "true", sleep for 5 seconds
    * otherwise sleep for 2 seconds

**Authorization:**

This endpoint requires that the user have `read` access to the Job or to Adhoc executions to retrieve the output content.



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Execution ID
 @return ApiApiExecutionOutputRequest
*/
func (a *ExecutionAPIService) ApiExecutionOutput(ctx context.Context, id string) ApiApiExecutionOutputRequest {
	return ApiApiExecutionOutputRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ExecutionAPIService) ApiExecutionOutputExecute(r ApiApiExecutionOutputRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionAPIService.ApiExecutionOutput")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/execution/{id}/output"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.nodename != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nodename", r.nodename, "form", "")
	}
	if r.stepctx != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stepctx", r.stepctx, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.lastlines != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lastlines", r.lastlines, "form", "")
	}
	if r.lastmod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lastmod", r.lastmod, "form", "")
	}
	if r.maxlines != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxlines", r.maxlines, "form", "")
	}
	if r.compacted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "compacted", r.compacted, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["rundeckApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Rundeck-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiExecutionOutputNodeFilterRequest struct {
	ctx context.Context
	ApiService *ExecutionAPIService
	id string
	nodename string
}

func (r ApiApiExecutionOutputNodeFilterRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ApiExecutionOutputNodeFilterExecute(r)
}

/*
ApiExecutionOutputNodeFilter Execution Output For Node

Get the output for an execution filtered for a specific node.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Execution ID
 @param nodename Node Name, all results will be filtered for only this node.
 @return ApiApiExecutionOutputNodeFilterRequest
*/
func (a *ExecutionAPIService) ApiExecutionOutputNodeFilter(ctx context.Context, id string, nodename string) ApiApiExecutionOutputNodeFilterRequest {
	return ApiApiExecutionOutputNodeFilterRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		nodename: nodename,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ExecutionAPIService) ApiExecutionOutputNodeFilterExecute(r ApiApiExecutionOutputNodeFilterRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionAPIService.ApiExecutionOutputNodeFilter")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/execution/{id}/output/node/{nodename}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"nodename"+"}", url.PathEscape(parameterValueToString(r.nodename, "nodename")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["rundeckApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Rundeck-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiExecutionOutputNodeStepFilterRequest struct {
	ctx context.Context
	ApiService *ExecutionAPIService
	id string
	nodename string
	stepctx string
}

func (r ApiApiExecutionOutputNodeStepFilterRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ApiExecutionOutputNodeStepFilterExecute(r)
}

/*
ApiExecutionOutputNodeStepFilter Execution Output For Node and Step

Get the output for an execution filtered for a specific node and step.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Execution ID
 @param nodename Node Name, all results will be filtered for only this node.
 @param stepctx Step Context ID. This is a string in the form `1/2/3` indicating the step context.
 @return ApiApiExecutionOutputNodeStepFilterRequest
*/
func (a *ExecutionAPIService) ApiExecutionOutputNodeStepFilter(ctx context.Context, id string, nodename string, stepctx string) ApiApiExecutionOutputNodeStepFilterRequest {
	return ApiApiExecutionOutputNodeStepFilterRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		nodename: nodename,
		stepctx: stepctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ExecutionAPIService) ApiExecutionOutputNodeStepFilterExecute(r ApiApiExecutionOutputNodeStepFilterRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionAPIService.ApiExecutionOutputNodeStepFilter")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/execution/{id}/output/node/{nodename}/step/{stepctx}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"nodename"+"}", url.PathEscape(parameterValueToString(r.nodename, "nodename")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"stepctx"+"}", url.PathEscape(parameterValueToString(r.stepctx, "stepctx")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["rundeckApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Rundeck-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiExecutionOutputStepFilterRequest struct {
	ctx context.Context
	ApiService *ExecutionAPIService
	id string
	stepctx string
}

func (r ApiApiExecutionOutputStepFilterRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ApiExecutionOutputStepFilterExecute(r)
}

/*
ApiExecutionOutputStepFilter Execution Output For Step

Get the output for an execution filtered for a specific step.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Execution ID
 @param stepctx Step Context ID. This is a string in the form `1/2/3` indicating the step context.
 @return ApiApiExecutionOutputStepFilterRequest
*/
func (a *ExecutionAPIService) ApiExecutionOutputStepFilter(ctx context.Context, id string, stepctx string) ApiApiExecutionOutputStepFilterRequest {
	return ApiApiExecutionOutputStepFilterRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		stepctx: stepctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ExecutionAPIService) ApiExecutionOutputStepFilterExecute(r ApiApiExecutionOutputStepFilterRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionAPIService.ApiExecutionOutputStepFilter")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/execution/{id}/output/step/{stepctx}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"stepctx"+"}", url.PathEscape(parameterValueToString(r.stepctx, "stepctx")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["rundeckApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Rundeck-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiExecutionStateRequest struct {
	ctx context.Context
	ApiService *ExecutionAPIService
	id string
}

func (r ApiApiExecutionStateRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ApiExecutionStateExecute(r)
}

/*
ApiExecutionState Execution State

Get detail about the node and step state of an execution by ID. The execution can be currently running or completed.

JSON response requires API v14.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Execution ID
 @return ApiApiExecutionStateRequest
*/
func (a *ExecutionAPIService) ApiExecutionState(ctx context.Context, id string) ApiApiExecutionStateRequest {
	return ApiApiExecutionStateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ExecutionAPIService) ApiExecutionStateExecute(r ApiApiExecutionStateRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionAPIService.ApiExecutionState")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/execution/{id}/state"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["rundeckApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Rundeck-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiExecutionStateOutputRequest struct {
	ctx context.Context
	ApiService *ExecutionAPIService
	id string
	stateOnly *bool
}

// Whether to include only state information. When false, log entries will be included.
func (r ApiApiExecutionStateOutputRequest) StateOnly(stateOnly bool) ApiApiExecutionStateOutputRequest {
	r.stateOnly = &stateOnly
	return r
}

func (r ApiApiExecutionStateOutputRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ApiExecutionStateOutputExecute(r)
}

/*
ApiExecutionStateOutput Execution Output with State

Get the metadata associated with workflow step state changes along with the log output, optionally excluding log output.

JSON response requires API v14.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Execution ID
 @return ApiApiExecutionStateOutputRequest
*/
func (a *ExecutionAPIService) ApiExecutionStateOutput(ctx context.Context, id string) ApiApiExecutionStateOutputRequest {
	return ApiApiExecutionStateOutputRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ExecutionAPIService) ApiExecutionStateOutputExecute(r ApiApiExecutionStateOutputRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionAPIService.ApiExecutionStateOutput")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/execution/{id}/output/state"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.stateOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stateOnly", r.stateOnly, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["rundeckApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Rundeck-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiExecutionsQueryv14DocsRequest struct {
	ctx context.Context
	ApiService *ExecutionAPIService
	project string
	statusFilter *string
	abortedbyFilter *string
	jobIdListFilter *string
	excludeJobIdListFilter *string
	jobListFilter *string
	excludeJobListFilter *string
	groupPath *string
	groupPathExact *string
	excludeGroupPath *string
	excludeGroupPathExact *string
	jobFilter *string
	excludeJobFilter *string
	jobExactFilter *string
	excludeJobExactFilter *string
	startafterFilter *string
	startbeforeFilter *string
	endafterFilter *string
	endbeforeFilter *string
	begin *string
	end *string
	adhoc *bool
	recentFilter *string
	olderFilter *string
	userFilter *string
	executionTypeFilter *string
	max *int32
	offset *int32
}

// Execution status
func (r ApiApiExecutionsQueryv14DocsRequest) StatusFilter(statusFilter string) ApiApiExecutionsQueryv14DocsRequest {
	r.statusFilter = &statusFilter
	return r
}

// Username who aborted an execution
func (r ApiApiExecutionsQueryv14DocsRequest) AbortedbyFilter(abortedbyFilter string) ApiApiExecutionsQueryv14DocsRequest {
	r.abortedbyFilter = &abortedbyFilter
	return r
}

// specify a Job ID to include, can be specified multiple times
func (r ApiApiExecutionsQueryv14DocsRequest) JobIdListFilter(jobIdListFilter string) ApiApiExecutionsQueryv14DocsRequest {
	r.jobIdListFilter = &jobIdListFilter
	return r
}

// specify a Job ID to exclude, can be specified multiple times
func (r ApiApiExecutionsQueryv14DocsRequest) ExcludeJobIdListFilter(excludeJobIdListFilter string) ApiApiExecutionsQueryv14DocsRequest {
	r.excludeJobIdListFilter = &excludeJobIdListFilter
	return r
}

// specify a full Job group/name to include, can be specified multiple times
func (r ApiApiExecutionsQueryv14DocsRequest) JobListFilter(jobListFilter string) ApiApiExecutionsQueryv14DocsRequest {
	r.jobListFilter = &jobListFilter
	return r
}

// specify a full Job group/name to exclude, can be specified multiple times
func (r ApiApiExecutionsQueryv14DocsRequest) ExcludeJobListFilter(excludeJobListFilter string) ApiApiExecutionsQueryv14DocsRequest {
	r.excludeJobListFilter = &excludeJobListFilter
	return r
}

// specify a group or partial group path to include all jobs within that group path. Set to the special value \&quot;-\&quot; to match the top level jobs only.
func (r ApiApiExecutionsQueryv14DocsRequest) GroupPath(groupPath string) ApiApiExecutionsQueryv14DocsRequest {
	r.groupPath = &groupPath
	return r
}

// specify an exact group path to match.  Set to the special value \&quot;-\&quot; to match the top level jobs only.
func (r ApiApiExecutionsQueryv14DocsRequest) GroupPathExact(groupPathExact string) ApiApiExecutionsQueryv14DocsRequest {
	r.groupPathExact = &groupPathExact
	return r
}

// specify a group or partial group path to exclude all jobs within that group path. Set to the special value \&quot;-\&quot; to match the top level jobs only.
func (r ApiApiExecutionsQueryv14DocsRequest) ExcludeGroupPath(excludeGroupPath string) ApiApiExecutionsQueryv14DocsRequest {
	r.excludeGroupPath = &excludeGroupPath
	return r
}

// specify an exact group path to exclude.  Set to the special value \&quot;-\&quot; to match the top level jobs only.
func (r ApiApiExecutionsQueryv14DocsRequest) ExcludeGroupPathExact(excludeGroupPathExact string) ApiApiExecutionsQueryv14DocsRequest {
	r.excludeGroupPathExact = &excludeGroupPathExact
	return r
}

// specify a filter for the job Name. Include any job name that matches this value
func (r ApiApiExecutionsQueryv14DocsRequest) JobFilter(jobFilter string) ApiApiExecutionsQueryv14DocsRequest {
	r.jobFilter = &jobFilter
	return r
}

// specify a filter for the job Name. Exclude any job name that matches this value.
func (r ApiApiExecutionsQueryv14DocsRequest) ExcludeJobFilter(excludeJobFilter string) ApiApiExecutionsQueryv14DocsRequest {
	r.excludeJobFilter = &excludeJobFilter
	return r
}

// specify an exact job name to match.
func (r ApiApiExecutionsQueryv14DocsRequest) JobExactFilter(jobExactFilter string) ApiApiExecutionsQueryv14DocsRequest {
	r.jobExactFilter = &jobExactFilter
	return r
}

// specify an exact job name to exclude.
func (r ApiApiExecutionsQueryv14DocsRequest) ExcludeJobExactFilter(excludeJobExactFilter string) ApiApiExecutionsQueryv14DocsRequest {
	r.excludeJobExactFilter = &excludeJobExactFilter
	return r
}

// start after date
func (r ApiApiExecutionsQueryv14DocsRequest) StartafterFilter(startafterFilter string) ApiApiExecutionsQueryv14DocsRequest {
	r.startafterFilter = &startafterFilter
	return r
}

// start before date
func (r ApiApiExecutionsQueryv14DocsRequest) StartbeforeFilter(startbeforeFilter string) ApiApiExecutionsQueryv14DocsRequest {
	r.startbeforeFilter = &startbeforeFilter
	return r
}

// end after date
func (r ApiApiExecutionsQueryv14DocsRequest) EndafterFilter(endafterFilter string) ApiApiExecutionsQueryv14DocsRequest {
	r.endafterFilter = &endafterFilter
	return r
}

// end before date
func (r ApiApiExecutionsQueryv14DocsRequest) EndbeforeFilter(endbeforeFilter string) ApiApiExecutionsQueryv14DocsRequest {
	r.endbeforeFilter = &endbeforeFilter
	return r
}

// Specify exact date for earliest execution completion time. Format: a unix millisecond timestamp, or a W3C dateTime string in the format \&quot;yyyy-MM-ddTHH:mm:ssZ\&quot;.
func (r ApiApiExecutionsQueryv14DocsRequest) Begin(begin string) ApiApiExecutionsQueryv14DocsRequest {
	r.begin = &begin
	return r
}

// Specify exact date for latest execution completion time. Format: a unix millisecond timestamp, or a W3C dateTime string in the format \&quot;yyyy-MM-ddTHH:mm:ssZ\&quot;.
func (r ApiApiExecutionsQueryv14DocsRequest) End(end string) ApiApiExecutionsQueryv14DocsRequest {
	r.end = &end
	return r
}

// if true, include only Adhoc executions, if false return only Job executions. By default any matching executions are returned, however if you use any of the Job filters below, then only Job executions will be returned.
func (r ApiApiExecutionsQueryv14DocsRequest) Adhoc(adhoc bool) ApiApiExecutionsQueryv14DocsRequest {
	r.adhoc = &adhoc
	return r
}

// Use a simple text format to filter executions that completed within a period of time. The format is \&quot;XY\&quot; where X is an integer, and \&quot;Y\&quot; is one of: * &#x60;s&#x60;: second * &#x60;n&#x60;: minute * &#x60;h&#x60;: hour * &#x60;d&#x60;: day * &#x60;w&#x60;: week * &#x60;m&#x60;: month * &#x60;y&#x60;: year  So a value of &#x60;2w&#x60; would return executions that completed within the last two weeks. 
func (r ApiApiExecutionsQueryv14DocsRequest) RecentFilter(recentFilter string) ApiApiExecutionsQueryv14DocsRequest {
	r.recentFilter = &recentFilter
	return r
}

// (same format as &#x60;recentFilter&#x60;) return executions that completed before the specified relative period of time.  E.g. a value of &#x60;30d&#x60; returns executions older than 30 days.
func (r ApiApiExecutionsQueryv14DocsRequest) OlderFilter(olderFilter string) ApiApiExecutionsQueryv14DocsRequest {
	r.olderFilter = &olderFilter
	return r
}

// Username who started the execution
func (r ApiApiExecutionsQueryv14DocsRequest) UserFilter(userFilter string) ApiApiExecutionsQueryv14DocsRequest {
	r.userFilter = &userFilter
	return r
}

// specify the execution type, one of: &#x60;scheduled&#x60; (schedule trigger), &#x60;user&#x60; (user trigger), &#x60;user-scheduled&#x60; (user scheduled trigger). Since: v20
func (r ApiApiExecutionsQueryv14DocsRequest) ExecutionTypeFilter(executionTypeFilter string) ApiApiExecutionsQueryv14DocsRequest {
	r.executionTypeFilter = &executionTypeFilter
	return r
}

// maximum number of results to include in response. (default: 20)
func (r ApiApiExecutionsQueryv14DocsRequest) Max(max int32) ApiApiExecutionsQueryv14DocsRequest {
	r.max = &max
	return r
}

// offset for first result to include. (default: 0)
func (r ApiApiExecutionsQueryv14DocsRequest) Offset(offset int32) ApiApiExecutionsQueryv14DocsRequest {
	r.offset = &offset
	return r
}

func (r ApiApiExecutionsQueryv14DocsRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiExecutionsQueryv14DocsExecute(r)
}

/*
ApiExecutionsQueryv14Docs Execution Query

Query for Executions based on Job or Execution details.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param project Project name
 @return ApiApiExecutionsQueryv14DocsRequest
*/
func (a *ExecutionAPIService) ApiExecutionsQueryv14Docs(ctx context.Context, project string) ApiApiExecutionsQueryv14DocsRequest {
	return ApiApiExecutionsQueryv14DocsRequest{
		ApiService: a,
		ctx: ctx,
		project: project,
	}
}

// Execute executes the request
func (a *ExecutionAPIService) ApiExecutionsQueryv14DocsExecute(r ApiApiExecutionsQueryv14DocsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionAPIService.ApiExecutionsQueryv14Docs")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project/{project}/executions"
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.statusFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "statusFilter", r.statusFilter, "form", "")
	}
	if r.abortedbyFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "abortedbyFilter", r.abortedbyFilter, "form", "")
	}
	if r.jobIdListFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "jobIdListFilter", r.jobIdListFilter, "form", "")
	}
	if r.excludeJobIdListFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludeJobIdListFilter", r.excludeJobIdListFilter, "form", "")
	}
	if r.jobListFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "jobListFilter", r.jobListFilter, "form", "")
	}
	if r.excludeJobListFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludeJobListFilter", r.excludeJobListFilter, "form", "")
	}
	if r.groupPath != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "groupPath", r.groupPath, "form", "")
	}
	if r.groupPathExact != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "groupPathExact", r.groupPathExact, "form", "")
	}
	if r.excludeGroupPath != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludeGroupPath", r.excludeGroupPath, "form", "")
	}
	if r.excludeGroupPathExact != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludeGroupPathExact", r.excludeGroupPathExact, "form", "")
	}
	if r.jobFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "jobFilter", r.jobFilter, "form", "")
	}
	if r.excludeJobFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludeJobFilter", r.excludeJobFilter, "form", "")
	}
	if r.jobExactFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "jobExactFilter", r.jobExactFilter, "form", "")
	}
	if r.excludeJobExactFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludeJobExactFilter", r.excludeJobExactFilter, "form", "")
	}
	if r.startafterFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startafterFilter", r.startafterFilter, "form", "")
	}
	if r.startbeforeFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startbeforeFilter", r.startbeforeFilter, "form", "")
	}
	if r.endafterFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endafterFilter", r.endafterFilter, "form", "")
	}
	if r.endbeforeFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endbeforeFilter", r.endbeforeFilter, "form", "")
	}
	if r.begin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "begin", r.begin, "form", "")
	}
	if r.end != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "form", "")
	}
	if r.adhoc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adhoc", r.adhoc, "form", "")
	}
	if r.recentFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recentFilter", r.recentFilter, "form", "")
	}
	if r.olderFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "olderFilter", r.olderFilter, "form", "")
	}
	if r.userFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userFilter", r.userFilter, "form", "")
	}
	if r.executionTypeFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "executionTypeFilter", r.executionTypeFilter, "form", "")
	}
	if r.max != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max", r.max, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["rundeckApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Rundeck-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiExecutionsRunningv14Request struct {
	ctx context.Context
	ApiService *ExecutionAPIService
	project string
	max *int32
	offset *int32
	jobIdFilter *string
	includePostponed *bool
}

// Paging maximum results, default: 20
func (r ApiApiExecutionsRunningv14Request) Max(max int32) ApiApiExecutionsRunningv14Request {
	r.max = &max
	return r
}

// Paging Offset
func (r ApiApiExecutionsRunningv14Request) Offset(offset int32) ApiApiExecutionsRunningv14Request {
	r.offset = &offset
	return r
}

// Specifies a Job ID, the results will only contain running executions for the given job. Since: v32
func (r ApiApiExecutionsRunningv14Request) JobIdFilter(jobIdFilter string) ApiApiExecutionsRunningv14Request {
	r.jobIdFilter = &jobIdFilter
	return r
}

// If true, include scheduled and queued executions. Since: v32
func (r ApiApiExecutionsRunningv14Request) IncludePostponed(includePostponed bool) ApiApiExecutionsRunningv14Request {
	r.includePostponed = &includePostponed
	return r
}

func (r ApiApiExecutionsRunningv14Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ApiExecutionsRunningv14Execute(r)
}

/*
ApiExecutionsRunningv14 Listing Running Executions

List the currently running executions for a project or all projects.

Authorization required: `read` for project resource type `event`


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param project Project Name, or * for all projects
 @return ApiApiExecutionsRunningv14Request
*/
func (a *ExecutionAPIService) ApiExecutionsRunningv14(ctx context.Context, project string) ApiApiExecutionsRunningv14Request {
	return ApiApiExecutionsRunningv14Request{
		ApiService: a,
		ctx: ctx,
		project: project,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ExecutionAPIService) ApiExecutionsRunningv14Execute(r ApiApiExecutionsRunningv14Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionAPIService.ApiExecutionsRunningv14")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project/{project}/executions/running"
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.max != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max", r.max, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.jobIdFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "jobIdFilter", r.jobIdFilter, "form", "")
	}
	if r.includePostponed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includePostponed", r.includePostponed, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["rundeckApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Rundeck-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiHomeSummaryRequest struct {
	ctx context.Context
	ApiService *ExecutionAPIService
}

func (r ApiApiHomeSummaryRequest) Execute() (*HomeSummary, *http.Response, error) {
	return r.ApiService.ApiHomeSummaryExecute(r)
}

/*
ApiHomeSummary Summary of executions and projects

Get Summary information about executions and projects.

Since: V45


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiHomeSummaryRequest
*/
func (a *ExecutionAPIService) ApiHomeSummary(ctx context.Context) ApiApiHomeSummaryRequest {
	return ApiApiHomeSummaryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return HomeSummary
func (a *ExecutionAPIService) ApiHomeSummaryExecute(r ApiApiHomeSummaryRequest) (*HomeSummary, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HomeSummary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ExecutionAPIService.ApiHomeSummary")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/home/summary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["rundeckApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Rundeck-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
