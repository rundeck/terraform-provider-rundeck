/*
Rundeck

Rundeck provides a Web API for use with your applications.

API version: 53
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// AuthorizationAPIService AuthorizationAPI service
type AuthorizationAPIService service

type ApiAppContextAuthorizationsForResourceKindRequest struct {
	ctx context.Context
	ApiService *AuthorizationAPIService
	kind string
	actions *[]string
}

// Actions to check authorization for
func (r ApiAppContextAuthorizationsForResourceKindRequest) Actions(actions []string) ApiAppContextAuthorizationsForResourceKindRequest {
	r.actions = &actions
	return r
}

func (r ApiAppContextAuthorizationsForResourceKindRequest) Execute() (*AuthorizationsResponse, *http.Response, error) {
	return r.ApiService.AppContextAuthorizationsForResourceKindExecute(r)
}

/*
AppContextAuthorizationsForResourceKind Get authorizations for an application resource kind

Get authorizations for the supplied set of actions for the subject executing the API call. 
Evaluation is made in the context of the application for the supplied resource kind.

**INCUBATING**: This endpoint is in "incubating" status, and may change.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param kind Resource Kind
 @return ApiAppContextAuthorizationsForResourceKindRequest
*/
func (a *AuthorizationAPIService) AppContextAuthorizationsForResourceKind(ctx context.Context, kind string) ApiAppContextAuthorizationsForResourceKindRequest {
	return ApiAppContextAuthorizationsForResourceKindRequest{
		ApiService: a,
		ctx: ctx,
		kind: kind,
	}
}

// Execute executes the request
//  @return AuthorizationsResponse
func (a *AuthorizationAPIService) AppContextAuthorizationsForResourceKindExecute(r ApiAppContextAuthorizationsForResourceKindRequest) (*AuthorizationsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuthorizationsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthorizationAPIService.AppContextAuthorizationsForResourceKind")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/authorizations/application/{kind}"
	localVarPath = strings.Replace(localVarPath, "{"+"kind"+"}", url.PathEscape(parameterValueToString(r.kind, "kind")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.actions == nil {
		return localVarReturnValue, nil, reportError("actions is required and must be specified")
	}

	{
		t := *r.actions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "actions", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "actions", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["rundeckApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Rundeck-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAppContextAuthorizationsForTypeWithSpecifierRequest struct {
	ctx context.Context
	ApiService *AuthorizationAPIService
	type_ string
	specifier string
	actions *[]string
}

// Actions to check authorization for
func (r ApiAppContextAuthorizationsForTypeWithSpecifierRequest) Actions(actions []string) ApiAppContextAuthorizationsForTypeWithSpecifierRequest {
	r.actions = &actions
	return r
}

func (r ApiAppContextAuthorizationsForTypeWithSpecifierRequest) Execute() (*AuthorizationsResponse, *http.Response, error) {
	return r.ApiService.AppContextAuthorizationsForTypeWithSpecifierExecute(r)
}

/*
AppContextAuthorizationsForTypeWithSpecifier Get authorizations for an application type with specifier

Get authorizations for the supplied set of actions for the subject executing the API call. 
Evaluation is made in the context of the application for the supplied type and specifier.

**INCUBATING**: This endpoint is in "incubating" status, and may change.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param type_ Resource Type
 @param specifier Resource specifier
 @return ApiAppContextAuthorizationsForTypeWithSpecifierRequest
*/
func (a *AuthorizationAPIService) AppContextAuthorizationsForTypeWithSpecifier(ctx context.Context, type_ string, specifier string) ApiAppContextAuthorizationsForTypeWithSpecifierRequest {
	return ApiAppContextAuthorizationsForTypeWithSpecifierRequest{
		ApiService: a,
		ctx: ctx,
		type_: type_,
		specifier: specifier,
	}
}

// Execute executes the request
//  @return AuthorizationsResponse
func (a *AuthorizationAPIService) AppContextAuthorizationsForTypeWithSpecifierExecute(r ApiAppContextAuthorizationsForTypeWithSpecifierRequest) (*AuthorizationsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuthorizationsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthorizationAPIService.AppContextAuthorizationsForTypeWithSpecifier")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/authorizations/application/{type}/{specifier}"
	localVarPath = strings.Replace(localVarPath, "{"+"type"+"}", url.PathEscape(parameterValueToString(r.type_, "type_")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"specifier"+"}", url.PathEscape(parameterValueToString(r.specifier, "specifier")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.actions == nil {
		return localVarReturnValue, nil, reportError("actions is required and must be specified")
	}

	{
		t := *r.actions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "actions", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "actions", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["rundeckApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Rundeck-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProjectContextAuthorizationsForJobRequest struct {
	ctx context.Context
	ApiService *AuthorizationAPIService
	project string
	specifier string
	actions *[]string
}

// Actions to check authorization for
func (r ApiProjectContextAuthorizationsForJobRequest) Actions(actions []string) ApiProjectContextAuthorizationsForJobRequest {
	r.actions = &actions
	return r
}

func (r ApiProjectContextAuthorizationsForJobRequest) Execute() (*AuthorizationsResponse, *http.Response, error) {
	return r.ApiService.ProjectContextAuthorizationsForJobExecute(r)
}

/*
ProjectContextAuthorizationsForJob Get authorizations for a job

Get authorizations for the supplied set of actions for the subject executing the API call. 
Evaluation is made in the context of the project for the supplied job.

**INCUBATING**: This endpoint is in "incubating" status, and may change.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param project Project Name
 @param specifier Job Id
 @return ApiProjectContextAuthorizationsForJobRequest
*/
func (a *AuthorizationAPIService) ProjectContextAuthorizationsForJob(ctx context.Context, project string, specifier string) ApiProjectContextAuthorizationsForJobRequest {
	return ApiProjectContextAuthorizationsForJobRequest{
		ApiService: a,
		ctx: ctx,
		project: project,
		specifier: specifier,
	}
}

// Execute executes the request
//  @return AuthorizationsResponse
func (a *AuthorizationAPIService) ProjectContextAuthorizationsForJobExecute(r ApiProjectContextAuthorizationsForJobRequest) (*AuthorizationsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuthorizationsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthorizationAPIService.ProjectContextAuthorizationsForJob")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/authorizations/project/{project}/job/{specifier}"
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"specifier"+"}", url.PathEscape(parameterValueToString(r.specifier, "specifier")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.actions == nil {
		return localVarReturnValue, nil, reportError("actions is required and must be specified")
	}

	{
		t := *r.actions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "actions", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "actions", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["rundeckApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Rundeck-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProjectContextAuthorizationsForResourceKindRequest struct {
	ctx context.Context
	ApiService *AuthorizationAPIService
	project string
	kind string
	actions *[]string
}

// Actions to check authorization for
func (r ApiProjectContextAuthorizationsForResourceKindRequest) Actions(actions []string) ApiProjectContextAuthorizationsForResourceKindRequest {
	r.actions = &actions
	return r
}

func (r ApiProjectContextAuthorizationsForResourceKindRequest) Execute() (*AuthorizationsResponse, *http.Response, error) {
	return r.ApiService.ProjectContextAuthorizationsForResourceKindExecute(r)
}

/*
ProjectContextAuthorizationsForResourceKind Get authorizations for a project resource kind

Get authorizations for the supplied set of actions for the subject executing the API call. 
Evaluation is made in the context of the project for the supplied resource kind.

**INCUBATING**: This endpoint is in "incubating" status, and may change.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param project Project Name
 @param kind Resource Kind
 @return ApiProjectContextAuthorizationsForResourceKindRequest
*/
func (a *AuthorizationAPIService) ProjectContextAuthorizationsForResourceKind(ctx context.Context, project string, kind string) ApiProjectContextAuthorizationsForResourceKindRequest {
	return ApiProjectContextAuthorizationsForResourceKindRequest{
		ApiService: a,
		ctx: ctx,
		project: project,
		kind: kind,
	}
}

// Execute executes the request
//  @return AuthorizationsResponse
func (a *AuthorizationAPIService) ProjectContextAuthorizationsForResourceKindExecute(r ApiProjectContextAuthorizationsForResourceKindRequest) (*AuthorizationsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuthorizationsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthorizationAPIService.ProjectContextAuthorizationsForResourceKind")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/authorizations/project/{project}/{kind}"
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"kind"+"}", url.PathEscape(parameterValueToString(r.kind, "kind")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.actions == nil {
		return localVarReturnValue, nil, reportError("actions is required and must be specified")
	}

	{
		t := *r.actions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "actions", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "actions", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["rundeckApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Rundeck-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProjectContextAuthorizationsForTypeWithSpecifierRequest struct {
	ctx context.Context
	ApiService *AuthorizationAPIService
	project string
	type_ string
	specifier string
	actions *[]string
}

// Actions to check authorization for
func (r ApiProjectContextAuthorizationsForTypeWithSpecifierRequest) Actions(actions []string) ApiProjectContextAuthorizationsForTypeWithSpecifierRequest {
	r.actions = &actions
	return r
}

func (r ApiProjectContextAuthorizationsForTypeWithSpecifierRequest) Execute() (*AuthorizationsResponse, *http.Response, error) {
	return r.ApiService.ProjectContextAuthorizationsForTypeWithSpecifierExecute(r)
}

/*
ProjectContextAuthorizationsForTypeWithSpecifier Get authorizations for a type with specifier

Get authorizations for the supplied set of actions for the subject executing the API call. 
Evaluation is made in the context of the project for the type with a specifier.

**INCUBATING**: This endpoint is in "incubating" status, and may change.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param project Project Name
 @param type_ Resource Type
 @param specifier Resource specifier
 @return ApiProjectContextAuthorizationsForTypeWithSpecifierRequest
*/
func (a *AuthorizationAPIService) ProjectContextAuthorizationsForTypeWithSpecifier(ctx context.Context, project string, type_ string, specifier string) ApiProjectContextAuthorizationsForTypeWithSpecifierRequest {
	return ApiProjectContextAuthorizationsForTypeWithSpecifierRequest{
		ApiService: a,
		ctx: ctx,
		project: project,
		type_: type_,
		specifier: specifier,
	}
}

// Execute executes the request
//  @return AuthorizationsResponse
func (a *AuthorizationAPIService) ProjectContextAuthorizationsForTypeWithSpecifierExecute(r ApiProjectContextAuthorizationsForTypeWithSpecifierRequest) (*AuthorizationsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AuthorizationsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthorizationAPIService.ProjectContextAuthorizationsForTypeWithSpecifier")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/authorizations/project/{project}/{type}/{specifier}"
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"type"+"}", url.PathEscape(parameterValueToString(r.type_, "type_")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"specifier"+"}", url.PathEscape(parameterValueToString(r.specifier, "specifier")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.actions == nil {
		return localVarReturnValue, nil, reportError("actions is required and must be specified")
	}

	{
		t := *r.actions
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "actions", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "actions", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["rundeckApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Rundeck-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
