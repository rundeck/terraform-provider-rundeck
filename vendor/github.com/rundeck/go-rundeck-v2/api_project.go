/*
Rundeck

Rundeck provides a Web API for use with your applications.

API version: 53
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"os"
)


// ProjectAPIService ProjectAPI service
type ProjectAPIService service

type ApiApiProjectAclsDeleteDocsRequest struct {
	ctx context.Context
	ApiService *ProjectAPIService
	project string
	path string
}

func (r ApiApiProjectAclsDeleteDocsRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiProjectAclsDeleteDocsExecute(r)
}

/*
ApiProjectAclsDeleteDocs Delete an ACL policy file.

Delete a project ACL policy file.

Authorization required: `delete` access for `Project ACL` resource type or `admin` or `app_admin` access for `user` resource type.
Since: v14

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param project Project Name
 @param path Path to the ACL policy
 @return ApiApiProjectAclsDeleteDocsRequest
*/
func (a *ProjectAPIService) ApiProjectAclsDeleteDocs(ctx context.Context, project string, path string) ApiApiProjectAclsDeleteDocsRequest {
	return ApiApiProjectAclsDeleteDocsRequest{
		ApiService: a,
		ctx: ctx,
		project: project,
		path: path,
	}
}

// Execute executes the request
func (a *ProjectAPIService) ApiProjectAclsDeleteDocsExecute(r ApiApiProjectAclsDeleteDocsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.ApiProjectAclsDeleteDocs")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project/{project}/acl/{path}"
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"path"+"}", url.PathEscape(parameterValueToString(r.path, "path")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["rundeckApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Rundeck-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiProjectAclsGetDocsRequest struct {
	ctx context.Context
	ApiService *ProjectAPIService
	project string
	path string
}

func (r ApiApiProjectAclsGetDocsRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.ApiProjectAclsGetDocsExecute(r)
}

/*
ApiProjectAclsGetDocs Get ACL Policy file for a project.

Retrieve the YAML text of the ACL Policy file for a project. 
If YAML or text content is requested, the contents will be returned directly. Otherwise if XML or JSON is requested, the YAML text will be wrapped within that format.

Authorization required: `read` access for `Project ACL` resource type or `admin` or `app_admin` access for `user` resource type.
Since: v14

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param project Project Name
 @param path Path to the Acl policy file
 @return ApiApiProjectAclsGetDocsRequest
*/
func (a *ProjectAPIService) ApiProjectAclsGetDocs(ctx context.Context, project string, path string) ApiApiProjectAclsGetDocsRequest {
	return ApiApiProjectAclsGetDocsRequest{
		ApiService: a,
		ctx: ctx,
		project: project,
		path: path,
	}
}

// Execute executes the request
//  @return string
func (a *ProjectAPIService) ApiProjectAclsGetDocsExecute(r ApiApiProjectAclsGetDocsRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.ApiProjectAclsGetDocs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project/{project}/acl/{path}"
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"path"+"}", url.PathEscape(parameterValueToString(r.path, "path")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/text", "application/yaml", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["rundeckApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Rundeck-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiProjectAclsPostDocsRequest struct {
	ctx context.Context
	ApiService *ProjectAPIService
	project string
	path string
	body *string
}

func (r ApiApiProjectAclsPostDocsRequest) Body(body string) ApiApiProjectAclsPostDocsRequest {
	r.body = &body
	return r
}

func (r ApiApiProjectAclsPostDocsRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.ApiProjectAclsPostDocsExecute(r)
}

/*
ApiProjectAclsPostDocs Update a Project ACL Policy

Use `POST` to create a policy.
If the Content-Type is `application/yaml` or `text/plain`, then the request body is the ACL policy contents directly. 
Otherwise if XML or JSON is requested, the YAML text will be wrapped within that format.

Authorization required: `create` access for `Project ACL` resource type or `admin` or `app_admin` access for `user` resource type.
Since: v14

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param project Project Name
 @param path Path to the ACL Policy
 @return ApiApiProjectAclsPostDocsRequest
*/
func (a *ProjectAPIService) ApiProjectAclsPostDocs(ctx context.Context, project string, path string) ApiApiProjectAclsPostDocsRequest {
	return ApiApiProjectAclsPostDocsRequest{
		ApiService: a,
		ctx: ctx,
		project: project,
		path: path,
	}
}

// Execute executes the request
//  @return string
func (a *ProjectAPIService) ApiProjectAclsPostDocsExecute(r ApiApiProjectAclsPostDocsRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.ApiProjectAclsPostDocs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project/{project}/acl/{path}"
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"path"+"}", url.PathEscape(parameterValueToString(r.path, "path")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"text/plain", "application/yaml", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/x-yaml", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["rundeckApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Rundeck-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiProjectAclsPutDocsRequest struct {
	ctx context.Context
	ApiService *ProjectAPIService
	project string
	path string
	body *string
}

func (r ApiApiProjectAclsPutDocsRequest) Body(body string) ApiApiProjectAclsPutDocsRequest {
	r.body = &body
	return r
}

func (r ApiApiProjectAclsPutDocsRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiProjectAclsPutDocsExecute(r)
}

/*
ApiProjectAclsPutDocs Update a Project ACL Policy

Use `PUT` to update a policy.
If the Content-Type is `application/yaml` or `text/plain`, then the request body is the ACL policy contents directly. 
Otherwise if XML or JSON is requested, the YAML text will be wrapped within that format.

Authorization required: `update` access for `Project ACL` resource type or `admin` or `app_admin` access for `user` resource type.
Since: v14

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param project Project Name
 @param path Path to the ACL Policy
 @return ApiApiProjectAclsPutDocsRequest
*/
func (a *ProjectAPIService) ApiProjectAclsPutDocs(ctx context.Context, project string, path string) ApiApiProjectAclsPutDocsRequest {
	return ApiApiProjectAclsPutDocsRequest{
		ApiService: a,
		ctx: ctx,
		project: project,
		path: path,
	}
}

// Execute executes the request
func (a *ProjectAPIService) ApiProjectAclsPutDocsExecute(r ApiApiProjectAclsPutDocsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.ApiProjectAclsPutDocs")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project/{project}/acl/{path}"
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"path"+"}", url.PathEscape(parameterValueToString(r.path, "path")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"text/plain", "application/x-yaml", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/text", "application/yaml", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["rundeckApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Rundeck-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiProjectConfigGetRequest struct {
	ctx context.Context
	ApiService *ProjectAPIService
	project string
}

func (r ApiApiProjectConfigGetRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.ApiProjectConfigGetExecute(r)
}

/*
ApiProjectConfigGet Get a project config

Retrieve the project configuration data.
The response, based on `Accept` header, can be returned in the Text, XML or Json format.

Authorization required: `configure` access for `project` resource type or `admin` or `app_admin` access for `user` resource type.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param project Project Name
 @return ApiApiProjectConfigGetRequest
*/
func (a *ProjectAPIService) ApiProjectConfigGet(ctx context.Context, project string) ApiApiProjectConfigGetRequest {
	return ApiApiProjectConfigGetRequest{
		ApiService: a,
		ctx: ctx,
		project: project,
	}
}

// Execute executes the request
//  @return string
func (a *ProjectAPIService) ApiProjectConfigGetExecute(r ApiApiProjectConfigGetRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.ApiProjectConfigGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project/{project}/config"
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/text", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["rundeckApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Rundeck-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiProjectConfigKeyDeleteRequest struct {
	ctx context.Context
	ApiService *ProjectAPIService
	project string
	keypath string
}

func (r ApiApiProjectConfigKeyDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiProjectConfigKeyDeleteExecute(r)
}

/*
ApiProjectConfigKeyDelete Delete the key

Delete an individual configuration properties by their key.

Authorization required: `configure` access for `project` resource type or `admin` or `app_admin` access for `user` resource type.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param project Project Name
 @param keypath Key Path
 @return ApiApiProjectConfigKeyDeleteRequest
*/
func (a *ProjectAPIService) ApiProjectConfigKeyDelete(ctx context.Context, project string, keypath string) ApiApiProjectConfigKeyDeleteRequest {
	return ApiApiProjectConfigKeyDeleteRequest{
		ApiService: a,
		ctx: ctx,
		project: project,
		keypath: keypath,
	}
}

// Execute executes the request
func (a *ProjectAPIService) ApiProjectConfigKeyDeleteExecute(r ApiApiProjectConfigKeyDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.ApiProjectConfigKeyDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project/{project}/config/{keypath}"
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"keypath"+"}", url.PathEscape(parameterValueToString(r.keypath, "keypath")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["rundeckApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Rundeck-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiProjectConfigKeyGetRequest struct {
	ctx context.Context
	ApiService *ProjectAPIService
	project string
	keypath string
}

func (r ApiApiProjectConfigKeyGetRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ApiProjectConfigKeyGetExecute(r)
}

/*
ApiProjectConfigKeyGet Get an individual project config by their key

Retrieve an individual configuration properties by their key.
The response, based on `Accept` header, can be returned in the Text, XML or Json format.

Authorization required: `configure` access for `project` resource type or `admin` or `app_admin` access for `user` resource type.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param project Project Name
 @param keypath Key Path
 @return ApiApiProjectConfigKeyGetRequest
*/
func (a *ProjectAPIService) ApiProjectConfigKeyGet(ctx context.Context, project string, keypath string) ApiApiProjectConfigKeyGetRequest {
	return ApiApiProjectConfigKeyGetRequest{
		ApiService: a,
		ctx: ctx,
		project: project,
		keypath: keypath,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ProjectAPIService) ApiProjectConfigKeyGetExecute(r ApiApiProjectConfigKeyGetRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.ApiProjectConfigKeyGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project/{project}/config/{keypath}"
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"keypath"+"}", url.PathEscape(parameterValueToString(r.keypath, "keypath")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/text", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["rundeckApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Rundeck-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiProjectConfigKeyPutRequest struct {
	ctx context.Context
	ApiService *ProjectAPIService
	project string
	keypath string
	enablePluginValidation *bool
	body *map[string]interface{}
}

// Enable plugin validation
func (r ApiApiProjectConfigKeyPutRequest) EnablePluginValidation(enablePluginValidation bool) ApiApiProjectConfigKeyPutRequest {
	r.enablePluginValidation = &enablePluginValidation
	return r
}

func (r ApiApiProjectConfigKeyPutRequest) Body(body map[string]interface{}) ApiApiProjectConfigKeyPutRequest {
	r.body = &body
	return r
}

func (r ApiApiProjectConfigKeyPutRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ApiProjectConfigKeyPutExecute(r)
}

/*
ApiProjectConfigKeyPut Set the value.

Replace an individual configuration data with the submitted value.
The response, based on `Accept` header, can be returned in the Text, XML or Json format.

Authorization required: `configure` access for `project` resource type or `admin` or `app_admin` access for `user` resource type.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param project Project Name
 @param keypath Key Path
 @return ApiApiProjectConfigKeyPutRequest
*/
func (a *ProjectAPIService) ApiProjectConfigKeyPut(ctx context.Context, project string, keypath string) ApiApiProjectConfigKeyPutRequest {
	return ApiApiProjectConfigKeyPutRequest{
		ApiService: a,
		ctx: ctx,
		project: project,
		keypath: keypath,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ProjectAPIService) ApiProjectConfigKeyPutExecute(r ApiApiProjectConfigKeyPutRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.ApiProjectConfigKeyPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project/{project}/config/{keypath}"
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"keypath"+"}", url.PathEscape(parameterValueToString(r.keypath, "keypath")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.enablePluginValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enablePluginValidation", r.enablePluginValidation, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/plain"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["rundeckApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Rundeck-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiProjectConfigPutRequest struct {
	ctx context.Context
	ApiService *ProjectAPIService
	project string
	body *map[string]interface{}
}

func (r ApiApiProjectConfigPutRequest) Body(body map[string]interface{}) ApiApiProjectConfigPutRequest {
	r.body = &body
	return r
}

func (r ApiApiProjectConfigPutRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ApiProjectConfigPutExecute(r)
}

/*
ApiProjectConfigPut Modify a project config

Replaces all configuration data with the submitted values.
The response, based on `Accept` header, can be returned in the Text, XML or Json format.

Authorization required: `configure` access for `project` resource type or `admin` or `app_admin` access for `user` resource type.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param project Project Name
 @return ApiApiProjectConfigPutRequest
*/
func (a *ProjectAPIService) ApiProjectConfigPut(ctx context.Context, project string) ApiApiProjectConfigPutRequest {
	return ApiApiProjectConfigPutRequest{
		ApiService: a,
		ctx: ctx,
		project: project,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ProjectAPIService) ApiProjectConfigPutExecute(r ApiApiProjectConfigPutRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.ApiProjectConfigPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project/{project}/config"
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/plain"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["rundeckApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Rundeck-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiProjectCreateRequest struct {
	ctx context.Context
	ApiService *ProjectAPIService
	body *map[string]interface{}
}

// Project Create contains a name, and configuration values
func (r ApiApiProjectCreateRequest) Body(body map[string]interface{}) ApiApiProjectCreateRequest {
	r.body = &body
	return r
}

func (r ApiApiProjectCreateRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ApiProjectCreateExecute(r)
}

/*
ApiProjectCreate Create a Project

Create a new project.

Authorization required: `create` for resource type `project`


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiProjectCreateRequest
*/
func (a *ProjectAPIService) ApiProjectCreate(ctx context.Context) ApiApiProjectCreateRequest {
	return ApiApiProjectCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ProjectAPIService) ApiProjectCreateExecute(r ApiApiProjectCreateRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.ApiProjectCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/projects"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["rundeckApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Rundeck-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiProjectDeleteRequest struct {
	ctx context.Context
	ApiService *ProjectAPIService
	project string
	deferred *bool
}

// Deferred Delete. Since: v45
func (r ApiApiProjectDeleteRequest) Deferred(deferred bool) ApiApiProjectDeleteRequest {
	r.deferred = &deferred
	return r
}

func (r ApiApiProjectDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiProjectDeleteExecute(r)
}

/*
ApiProjectDelete Delete a project

Delete an existing projects on the server.

Authorization required: `delete` access for `project` resource type or `admin` or `app_admin` access for `user` resource type.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param project Project Name
 @return ApiApiProjectDeleteRequest
*/
func (a *ProjectAPIService) ApiProjectDelete(ctx context.Context, project string) ApiApiProjectDeleteRequest {
	return ApiApiProjectDeleteRequest{
		ApiService: a,
		ctx: ctx,
		project: project,
	}
}

// Execute executes the request
func (a *ProjectAPIService) ApiProjectDeleteExecute(r ApiApiProjectDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.ApiProjectDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project/{project}"
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.deferred != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deferred", r.deferred, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["rundeckApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Rundeck-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiProjectExportRequest struct {
	ctx context.Context
	ApiService *ProjectAPIService
	project string
	archiveParams *ProjectArchiveParams
	executionIds *string
	exportAll *string
	exportJobs *string
	exportExecutions *string
	exportConfigs *string
	exportReadmes *string
	exportAcls *string
	exportComponentsCalendars *string
	exportComponentsSchedule20Definitions *string
	exportComponentsToursManager *string
	exportComponentsNodeWizard *string
}

func (r ApiApiProjectExportRequest) ArchiveParams(archiveParams ProjectArchiveParams) ApiApiProjectExportRequest {
	r.archiveParams = &archiveParams
	return r
}

// List of execution to include to the exported archive
func (r ApiApiProjectExportRequest) ExecutionIds(executionIds string) ApiApiProjectExportRequest {
	r.executionIds = &executionIds
	return r
}

// true/false, include all project contents (default: true)
func (r ApiApiProjectExportRequest) ExportAll(exportAll string) ApiApiProjectExportRequest {
	r.exportAll = &exportAll
	return r
}

// true/false, include jobs
func (r ApiApiProjectExportRequest) ExportJobs(exportJobs string) ApiApiProjectExportRequest {
	r.exportJobs = &exportJobs
	return r
}

// true/false, include executions
func (r ApiApiProjectExportRequest) ExportExecutions(exportExecutions string) ApiApiProjectExportRequest {
	r.exportExecutions = &exportExecutions
	return r
}

// true/false, include project configuration
func (r ApiApiProjectExportRequest) ExportConfigs(exportConfigs string) ApiApiProjectExportRequest {
	r.exportConfigs = &exportConfigs
	return r
}

// true/false, include project readme/motd files
func (r ApiApiProjectExportRequest) ExportReadmes(exportReadmes string) ApiApiProjectExportRequest {
	r.exportReadmes = &exportReadmes
	return r
}

// true/false, include project ACL Policy files, if authorized
func (r ApiApiProjectExportRequest) ExportAcls(exportAcls string) ApiApiProjectExportRequest {
	r.exportAcls = &exportAcls
	return r
}

// true/false, include project calendars
func (r ApiApiProjectExportRequest) ExportComponentsCalendars(exportComponentsCalendars string) ApiApiProjectExportRequest {
	r.exportComponentsCalendars = &exportComponentsCalendars
	return r
}

// true/false, include schedule definitions
func (r ApiApiProjectExportRequest) ExportComponentsSchedule20Definitions(exportComponentsSchedule20Definitions string) ApiApiProjectExportRequest {
	r.exportComponentsSchedule20Definitions = &exportComponentsSchedule20Definitions
	return r
}

// true/false, include tours manager
func (r ApiApiProjectExportRequest) ExportComponentsToursManager(exportComponentsToursManager string) ApiApiProjectExportRequest {
	r.exportComponentsToursManager = &exportComponentsToursManager
	return r
}

// true/false, include node wizard
func (r ApiApiProjectExportRequest) ExportComponentsNodeWizard(exportComponentsNodeWizard string) ApiApiProjectExportRequest {
	r.exportComponentsNodeWizard = &exportComponentsNodeWizard
	return r
}

func (r ApiApiProjectExportRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ApiProjectExportExecute(r)
}

/*
ApiProjectExport Export a zip archive of the project.

Performs the export to a zip archive of the project synchronously. 
Optional parameters:

* executionIds a list (comma-separated) of execution IDs. If this is specified then the archive will contain only executions that are specified, and will not contain Jobs, ACLs, or project configuration/readme files.
* optionally use POST method with with application/x-www-form-urlencoded content for large lists of execution IDs
* optionally, specify executionIds multiple times, with a single ID per entry.

In APIv19 or later:

By default, exportALL=true. So, in order to not export empty data, you need to include one of the parameter flags.

In APIv28 or later:

* exportScm true/false, include project SCM configuration, if authorized

In APIv34 or later:

* exportWebhooks true/false, include project webhooks in the archive
* whkIncludeAuthTokens true/false, include the auth token information when exporting webhooks, if not included the auth tokens will be regenerated upon import

Requires `export` authorization for the project resource.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param project Project Name
 @return ApiApiProjectExportRequest
*/
func (a *ProjectAPIService) ApiProjectExport(ctx context.Context, project string) ApiApiProjectExportRequest {
	return ApiApiProjectExportRequest{
		ApiService: a,
		ctx: ctx,
		project: project,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ProjectAPIService) ApiProjectExportExecute(r ApiApiProjectExportRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.ApiProjectExport")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project/{project}/export"
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.archiveParams == nil {
		return localVarReturnValue, nil, reportError("archiveParams is required and must be specified")
	}

	if r.executionIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "executionIds", r.executionIds, "form", "")
	}
	if r.exportAll != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exportAll", r.exportAll, "form", "")
	}
	if r.exportJobs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exportJobs", r.exportJobs, "form", "")
	}
	if r.exportExecutions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exportExecutions", r.exportExecutions, "form", "")
	}
	if r.exportConfigs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exportConfigs", r.exportConfigs, "form", "")
	}
	if r.exportReadmes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exportReadmes", r.exportReadmes, "form", "")
	}
	if r.exportAcls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exportAcls", r.exportAcls, "form", "")
	}
	if r.exportComponentsCalendars != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exportComponents.calendars", r.exportComponentsCalendars, "form", "")
	}
	if r.exportComponentsSchedule20Definitions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exportComponents.Schedule%20Definitions", r.exportComponentsSchedule20Definitions, "form", "")
	}
	if r.exportComponentsToursManager != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exportComponents.tours-manager", r.exportComponentsToursManager, "form", "")
	}
	if r.exportComponentsNodeWizard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exportComponents.node-wizard", r.exportComponentsNodeWizard, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "archiveParams", r.archiveParams, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/zip", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["rundeckApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Rundeck-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiProjectExportAsyncDocsRequest struct {
	ctx context.Context
	ApiService *ProjectAPIService
	project string
	executionIds *string
	exportAll *string
	exportJobs *string
	exportExecutions *string
	exportConfigs *string
	exportReadmes *string
	exportAcls *string
	exportComponentsCalendars *string
	exportComponentsSchedule20Definitions *string
	exportComponentsToursManager *string
	exportComponentsNodeWizard *string
}

// List of execution to include to the exported archive
func (r ApiApiProjectExportAsyncDocsRequest) ExecutionIds(executionIds string) ApiApiProjectExportAsyncDocsRequest {
	r.executionIds = &executionIds
	return r
}

// true/false, include all project contents (default: true)
func (r ApiApiProjectExportAsyncDocsRequest) ExportAll(exportAll string) ApiApiProjectExportAsyncDocsRequest {
	r.exportAll = &exportAll
	return r
}

// true/false, include jobs
func (r ApiApiProjectExportAsyncDocsRequest) ExportJobs(exportJobs string) ApiApiProjectExportAsyncDocsRequest {
	r.exportJobs = &exportJobs
	return r
}

// true/false, include executions
func (r ApiApiProjectExportAsyncDocsRequest) ExportExecutions(exportExecutions string) ApiApiProjectExportAsyncDocsRequest {
	r.exportExecutions = &exportExecutions
	return r
}

// true/false, include project configuration
func (r ApiApiProjectExportAsyncDocsRequest) ExportConfigs(exportConfigs string) ApiApiProjectExportAsyncDocsRequest {
	r.exportConfigs = &exportConfigs
	return r
}

// true/false, include project readme/motd files
func (r ApiApiProjectExportAsyncDocsRequest) ExportReadmes(exportReadmes string) ApiApiProjectExportAsyncDocsRequest {
	r.exportReadmes = &exportReadmes
	return r
}

// true/false, include project ACL Policy files, if authorized
func (r ApiApiProjectExportAsyncDocsRequest) ExportAcls(exportAcls string) ApiApiProjectExportAsyncDocsRequest {
	r.exportAcls = &exportAcls
	return r
}

// true/false, include project calendars
func (r ApiApiProjectExportAsyncDocsRequest) ExportComponentsCalendars(exportComponentsCalendars string) ApiApiProjectExportAsyncDocsRequest {
	r.exportComponentsCalendars = &exportComponentsCalendars
	return r
}

// true/false, include schedule definitions
func (r ApiApiProjectExportAsyncDocsRequest) ExportComponentsSchedule20Definitions(exportComponentsSchedule20Definitions string) ApiApiProjectExportAsyncDocsRequest {
	r.exportComponentsSchedule20Definitions = &exportComponentsSchedule20Definitions
	return r
}

// true/false, include tours manager
func (r ApiApiProjectExportAsyncDocsRequest) ExportComponentsToursManager(exportComponentsToursManager string) ApiApiProjectExportAsyncDocsRequest {
	r.exportComponentsToursManager = &exportComponentsToursManager
	return r
}

// true/false, include node wizard
func (r ApiApiProjectExportAsyncDocsRequest) ExportComponentsNodeWizard(exportComponentsNodeWizard string) ApiApiProjectExportAsyncDocsRequest {
	r.exportComponentsNodeWizard = &exportComponentsNodeWizard
	return r
}

func (r ApiApiProjectExportAsyncDocsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ApiProjectExportAsyncDocsExecute(r)
}

/*
ApiProjectExportAsyncDocs Export a zip archive of the project asynchronously.

Performs the export to a zip archive of the project asynchronously.
Use the Token result to query the export status and to retrieve the result once ready 
Optional parameters:

* executionIds a list (comma-separated) of execution IDs. If this is specified then the archive will contain only executions that are specified, and will not contain Jobs, ACLs, or project configuration/readme files.
* optionally use POST method with with application/x-www-form-urlencoded content for large lists of execution IDs
* optionally, specify executionIds multiple times, with a single ID per entry.

In APIv19 or later:

By default, exportALL=true. So, in order to not export empty data, you need to include one of the parameter flags.

In APIv28 or later:

* exportScm true/false, include project SCM configuration, if authorized

In APIv34 or later:

* exportWebhooks true/false, include project webhooks in the archive
* whkIncludeAuthTokens true/false, include the auth token information when exporting webhooks, if not included the auth tokens will be regenerated upon import

Requires `export` authorization for the project resource.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param project Project Name
 @return ApiApiProjectExportAsyncDocsRequest
*/
func (a *ProjectAPIService) ApiProjectExportAsyncDocs(ctx context.Context, project string) ApiApiProjectExportAsyncDocsRequest {
	return ApiApiProjectExportAsyncDocsRequest{
		ApiService: a,
		ctx: ctx,
		project: project,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ProjectAPIService) ApiProjectExportAsyncDocsExecute(r ApiApiProjectExportAsyncDocsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.ApiProjectExportAsyncDocs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project/{project}/export/async"
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.executionIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "executionIds", r.executionIds, "form", "")
	}
	if r.exportAll != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exportAll", r.exportAll, "form", "")
	}
	if r.exportJobs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exportJobs", r.exportJobs, "form", "")
	}
	if r.exportExecutions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exportExecutions", r.exportExecutions, "form", "")
	}
	if r.exportConfigs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exportConfigs", r.exportConfigs, "form", "")
	}
	if r.exportReadmes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exportReadmes", r.exportReadmes, "form", "")
	}
	if r.exportAcls != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exportAcls", r.exportAcls, "form", "")
	}
	if r.exportComponentsCalendars != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exportComponents.calendars", r.exportComponentsCalendars, "form", "")
	}
	if r.exportComponentsSchedule20Definitions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exportComponents.Schedule%20Definitions", r.exportComponentsSchedule20Definitions, "form", "")
	}
	if r.exportComponentsToursManager != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exportComponents.tours-manager", r.exportComponentsToursManager, "form", "")
	}
	if r.exportComponentsNodeWizard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exportComponents.node-wizard", r.exportComponentsNodeWizard, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["rundeckApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Rundeck-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiProjectExportAsyncDownloadRequest struct {
	ctx context.Context
	ApiService *ProjectAPIService
	project string
	token string
}

func (r ApiApiProjectExportAsyncDownloadRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ApiProjectExportAsyncDownloadExecute(r)
}

/*
ApiProjectExportAsyncDownload Download the zip archive file

Download the archive file once the export status is `ready`.

Requires `export` authorization for the project resource.
Since: v19

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param project Project Name
 @param token Token to retrieve export status
 @return ApiApiProjectExportAsyncDownloadRequest
*/
func (a *ProjectAPIService) ApiProjectExportAsyncDownload(ctx context.Context, project string, token string) ApiApiProjectExportAsyncDownloadRequest {
	return ApiApiProjectExportAsyncDownloadRequest{
		ApiService: a,
		ctx: ctx,
		project: project,
		token: token,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ProjectAPIService) ApiProjectExportAsyncDownloadExecute(r ApiApiProjectExportAsyncDownloadRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.ApiProjectExportAsyncDownload")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project/{project}/export/download/{token}"
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"token"+"}", url.PathEscape(parameterValueToString(r.token, "token")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/zip", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["rundeckApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Rundeck-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiProjectExportAsyncStatusRequest struct {
	ctx context.Context
	ApiService *ProjectAPIService
	project string
	token string
}

func (r ApiApiProjectExportAsyncStatusRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ApiProjectExportAsyncStatusExecute(r)
}

/*
ApiProjectExportAsyncStatus Get the status of an async export request

Get the status of an async export request. 
Retrieve the result once ready with `/api/V/project/[PROJECT]/export/download/[TOKEN]`.

Requires `export` authorization for the project resource.
Since: v19

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param project Project Name
 @param token Token to retrieve export status
 @return ApiApiProjectExportAsyncStatusRequest
*/
func (a *ProjectAPIService) ApiProjectExportAsyncStatus(ctx context.Context, project string, token string) ApiApiProjectExportAsyncStatusRequest {
	return ApiApiProjectExportAsyncStatusRequest{
		ApiService: a,
		ctx: ctx,
		project: project,
		token: token,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ProjectAPIService) ApiProjectExportAsyncStatusExecute(r ApiApiProjectExportAsyncStatusRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.ApiProjectExportAsyncStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project/{project}/export/status/{token}"
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"token"+"}", url.PathEscape(parameterValueToString(r.token, "token")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["rundeckApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Rundeck-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiProjectFileDeleteRequest struct {
	ctx context.Context
	ApiService *ProjectAPIService
	project string
	filename string
}

func (r ApiApiProjectFileDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiProjectFileDeleteExecute(r)
}

/*
ApiProjectFileDelete Delete `readme.md` and `motd.md`

Delete the `readme.md` and `motd.md` files, which are Markdown formatted and displayed in the Project listing page.

Authorization required: `configure` access for `project` resource type or `admin` or `app_admin` access for `user` resource type.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param project Project Name
 @param filename `readme.md` or `motd.md` file name
 @return ApiApiProjectFileDeleteRequest
*/
func (a *ProjectAPIService) ApiProjectFileDelete(ctx context.Context, project string, filename string) ApiApiProjectFileDeleteRequest {
	return ApiApiProjectFileDeleteRequest{
		ApiService: a,
		ctx: ctx,
		project: project,
		filename: filename,
	}
}

// Execute executes the request
func (a *ProjectAPIService) ApiProjectFileDeleteExecute(r ApiApiProjectFileDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.ApiProjectFileDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project/{project}/{filename}"
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"filename"+"}", url.PathEscape(parameterValueToString(r.filename, "filename")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["rundeckApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Rundeck-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiProjectFileGetRequest struct {
	ctx context.Context
	ApiService *ProjectAPIService
	project string
	filename string
}

func (r ApiApiProjectFileGetRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.ApiProjectFileGetExecute(r)
}

/*
ApiProjectFileGet Get `readme.md` and `motd.md`

Retrieve the `readme.md` and `motd.md` files, which are Markdown formatted and displayed in the Project listing page.
The response, based on `Accept` header, can be returned in the Text, XML or Json format.

Authorization required: `configure` access for `project` resource type or `admin` or `app_admin` access for `user` resource type.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param project Project Name
 @param filename `readme.md` or `motd.md` file name
 @return ApiApiProjectFileGetRequest
*/
func (a *ProjectAPIService) ApiProjectFileGet(ctx context.Context, project string, filename string) ApiApiProjectFileGetRequest {
	return ApiApiProjectFileGetRequest{
		ApiService: a,
		ctx: ctx,
		project: project,
		filename: filename,
	}
}

// Execute executes the request
//  @return string
func (a *ProjectAPIService) ApiProjectFileGetExecute(r ApiApiProjectFileGetRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.ApiProjectFileGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project/{project}/{filename}"
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"filename"+"}", url.PathEscape(parameterValueToString(r.filename, "filename")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/text", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["rundeckApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Rundeck-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiProjectFilePutRequest struct {
	ctx context.Context
	ApiService *ProjectAPIService
	project string
	filename string
	body *map[string]interface{}
}

func (r ApiApiProjectFilePutRequest) Body(body map[string]interface{}) ApiApiProjectFilePutRequest {
	r.body = &body
	return r
}

func (r ApiApiProjectFilePutRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.ApiProjectFilePutExecute(r)
}

/*
ApiProjectFilePut To create or modify the `readme.md` and `motd.md` contents

Create or modify the `readme.md` and `motd.md` files, which are Markdown formatted and displayed in the Project listing page.
The response, based on `Accept` header, can be returned in the Text, XML or Json format.

Authorization required: `configure` access for `project` resource type or `admin` or `app_admin` access for `user` resource type.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param project Project Name
 @param filename `readme.md` and `motd.md` file name
 @return ApiApiProjectFilePutRequest
*/
func (a *ProjectAPIService) ApiProjectFilePut(ctx context.Context, project string, filename string) ApiApiProjectFilePutRequest {
	return ApiApiProjectFilePutRequest{
		ApiService: a,
		ctx: ctx,
		project: project,
		filename: filename,
	}
}

// Execute executes the request
//  @return string
func (a *ProjectAPIService) ApiProjectFilePutExecute(r ApiApiProjectFilePutRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.ApiProjectFilePut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project/{project}/{filename}"
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"filename"+"}", url.PathEscape(parameterValueToString(r.filename, "filename")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/plain"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/text", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["rundeckApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Rundeck-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiProjectGetRequest struct {
	ctx context.Context
	ApiService *ProjectAPIService
	project string
}

func (r ApiApiProjectGetRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ApiProjectGetExecute(r)
}

/*
ApiProjectGet Get a project

Get information about a project.
The reponse in XML or JSON format is determined by the Accept request header.

Authorization required: `read` access for `project` resource type to get basic project details and `configure` access to get all properties config or `admin` or `app_admin` access for `user` resource type.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param project Project Name
 @return ApiApiProjectGetRequest
*/
func (a *ProjectAPIService) ApiProjectGet(ctx context.Context, project string) ApiApiProjectGetRequest {
	return ApiApiProjectGetRequest{
		ApiService: a,
		ctx: ctx,
		project: project,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ProjectAPIService) ApiProjectGetExecute(r ApiApiProjectGetRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.ApiProjectGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project/{project}"
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["rundeckApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Rundeck-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiProjectImportRequest struct {
	ctx context.Context
	ApiService *ProjectAPIService
	project string
	jobUuidOption *string
	importExecutions *bool
	importConfig *bool
	importACL *bool
	importScm *bool
	importWebhooks *bool
	whkRegenAuthTokens *bool
	importNodesSources *bool
	importComponentsNAME *string
	importOptsNAMEKEY *string
	body *os.File
}

// Option declaring how duplicate Job UUIDs should be handled.  If preserve (default) then imported job UUIDs will not be modified, and may conflict with jobs in other projects.  If remove then all job UUIDs will be removed before importing.
func (r ApiApiProjectImportRequest) JobUuidOption(jobUuidOption string) ApiApiProjectImportRequest {
	r.jobUuidOption = &jobUuidOption
	return r
}

// If true, import all executions and logs from the archive (default).  If false, do not import executions or logs.
func (r ApiApiProjectImportRequest) ImportExecutions(importExecutions bool) ApiApiProjectImportRequest {
	r.importExecutions = &importExecutions
	return r
}

// If true, import the project configuration from the archive.  If false, do not import the project configuration (default).
func (r ApiApiProjectImportRequest) ImportConfig(importConfig bool) ApiApiProjectImportRequest {
	r.importConfig = &importConfig
	return r
}

// If true, import all of the ACL Policies from the archive.  If false, do not import the ACL Policies (default).
func (r ApiApiProjectImportRequest) ImportACL(importACL bool) ApiApiProjectImportRequest {
	r.importACL = &importACL
	return r
}

// If true, import SCM configuration from the archive.  If false, do not import the SCM configuration (default).
func (r ApiApiProjectImportRequest) ImportScm(importScm bool) ApiApiProjectImportRequest {
	r.importScm = &importScm
	return r
}

// In APIv34 or later: If true, import the webhooks in the archive.  If false, do not import webhooks (default).
func (r ApiApiProjectImportRequest) ImportWebhooks(importWebhooks bool) ApiApiProjectImportRequest {
	r.importWebhooks = &importWebhooks
	return r
}

// In APIv34 or later: If true, always regenerate the auth tokens associated with the webhook.  If false, the webhook auth token in the archive will be imported.  If no auth token info was included with the webhook, it will be generated (default).
func (r ApiApiProjectImportRequest) WhkRegenAuthTokens(whkRegenAuthTokens bool) ApiApiProjectImportRequest {
	r.whkRegenAuthTokens = &whkRegenAuthTokens
	return r
}

// In APIv38 or later: If true, import Node Resources Source defined on project properties.  If false, do not import the nodes sources.
func (r ApiApiProjectImportRequest) ImportNodesSources(importNodesSources bool) ApiApiProjectImportRequest {
	r.importNodesSources = &importNodesSources
	return r
}

// Enable a component for import. Project archives may contain \&quot;components\&quot; which can be imported, beyond the base set of contents. This includes some data used by Process Automation (Rundeck Enterprise) features.  For example, to enable Webhook import, you could use &#x60;importWebhooks&#x60; and &#x60;whkRegenAuthTokens&#x60; params, but those are simply shortcuts for the following parameters:  * &#x60;importComponents.webhooks&#x3D;true&amp;importOpts.webhooks.regenAuthTokens&#x3D;true&#x60;  Import schedules definitions:  * &#x60;importComponents.Schedule%20Definitions&#x3D;true&#x60;
func (r ApiApiProjectImportRequest) ImportComponentsNAME(importComponentsNAME string) ApiApiProjectImportRequest {
	r.importComponentsNAME = &importComponentsNAME
	return r
}

// Set a component option. See &#x60;importComponents.NAME&#x60; parameter description
func (r ApiApiProjectImportRequest) ImportOptsNAMEKEY(importOptsNAMEKEY string) ApiApiProjectImportRequest {
	r.importOptsNAMEKEY = &importOptsNAMEKEY
	return r
}

func (r ApiApiProjectImportRequest) Body(body *os.File) ApiApiProjectImportRequest {
	r.body = body
	return r
}

func (r ApiApiProjectImportRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ApiProjectImportExecute(r)
}

/*
ApiProjectImport Import a zip archive.

Import a zip archive to the project.
Note: the import status indicates "failed" if any Jobs had failures, otherwise it indicates "successful" even if other files in the archive were not imported.

Requires `import` authorization for the project resource.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param project Project Name
 @return ApiApiProjectImportRequest
*/
func (a *ProjectAPIService) ApiProjectImport(ctx context.Context, project string) ApiApiProjectImportRequest {
	return ApiApiProjectImportRequest{
		ApiService: a,
		ctx: ctx,
		project: project,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ProjectAPIService) ApiProjectImportExecute(r ApiApiProjectImportRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.ApiProjectImport")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project/{project}/import"
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.jobUuidOption != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "jobUuidOption", r.jobUuidOption, "form", "")
	}
	if r.importExecutions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importExecutions", r.importExecutions, "form", "")
	}
	if r.importConfig != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importConfig ", r.importConfig, "form", "")
	}
	if r.importACL != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importACL ", r.importACL, "form", "")
	}
	if r.importScm != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importScm ", r.importScm, "form", "")
	}
	if r.importWebhooks != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importWebhooks", r.importWebhooks, "form", "")
	}
	if r.whkRegenAuthTokens != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "whkRegenAuthTokens", r.whkRegenAuthTokens, "form", "")
	}
	if r.importNodesSources != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importNodesSources", r.importNodesSources, "form", "")
	}
	if r.importComponentsNAME != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importComponents.NAME", r.importComponentsNAME, "form", "")
	}
	if r.importOptsNAMEKEY != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "importOpts.NAME.KEY", r.importOptsNAMEKEY, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/zip"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["rundeckApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Rundeck-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiProjectListRequest struct {
	ctx context.Context
	ApiService *ProjectAPIService
	meta *string
}

// Comma-separated list of metadata items to include, or \&quot;*\&quot; for all
func (r ApiApiProjectListRequest) Meta(meta string) ApiApiProjectListRequest {
	r.meta = &meta
	return r
}

func (r ApiApiProjectListRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.ApiProjectListExecute(r)
}

/*
ApiProjectList List Projects

List the existing projects on the server.

Authorization required: `read` for project resource


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiProjectListRequest
*/
func (a *ProjectAPIService) ApiProjectList(ctx context.Context) ApiApiProjectListRequest {
	return ApiApiProjectListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *ProjectAPIService) ApiProjectListExecute(r ApiApiProjectListRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.ApiProjectList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/projects"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.meta != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "meta", r.meta, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["rundeckApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Rundeck-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiProjectMetaRequest struct {
	ctx context.Context
	ApiService *ProjectAPIService
	project string
	meta *string
}

// Comma-separated list of metadata items to include, or \&quot;*\&quot; for all (default)
func (r ApiApiProjectMetaRequest) Meta(meta string) ApiApiProjectMetaRequest {
	r.meta = &meta
	return r
}

func (r ApiApiProjectMetaRequest) Execute() ([]ItemMeta, *http.Response, error) {
	return r.ApiService.ApiProjectMetaExecute(r)
}

/*
ApiProjectMeta Get Project UI Metadata

Get project metadata.

Requires `read` authorization for the project resource.
Since: v46

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param project Project name
 @return ApiApiProjectMetaRequest
*/
func (a *ProjectAPIService) ApiProjectMeta(ctx context.Context, project string) ApiApiProjectMetaRequest {
	return ApiApiProjectMetaRequest{
		ApiService: a,
		ctx: ctx,
		project: project,
	}
}

// Execute executes the request
//  @return []ItemMeta
func (a *ProjectAPIService) ApiProjectMetaExecute(r ApiApiProjectMetaRequest) ([]ItemMeta, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ItemMeta
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.ApiProjectMeta")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project/{project}/meta"
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.meta == nil {
		return localVarReturnValue, nil, reportError("meta is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "meta", r.meta, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["rundeckApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Rundeck-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiResourcesv2Request struct {
	ctx context.Context
	ApiService *ProjectAPIService
	project string
	filter *string
}

// Node Filter String
func (r ApiApiResourcesv2Request) Filter(filter string) ApiApiResourcesv2Request {
	r.filter = &filter
	return r
}

func (r ApiApiResourcesv2Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ApiResourcesv2Execute(r)
}

/*
ApiResourcesv2 List Project Nodes

List or query the nodes (resources) for a project.

Node Filter parameters: You can select nodes to include and exclude in the result set, see below.

**Note:** If no query parameters are included, the result set will include all Node resources for the project.

Refer to the [User Guide - Node Filters](https://docs.rundeck.com/docs/manual/11-node-filters.html) Documentation for information on
the node filter syntax and usage.

A basic node filter looks like:

    attribute: value attribute2: value2

To specify a Node Filter string as a URL parameter for an API request, use a parameter named `filter`.
Your HTTP client will have to correctly escape the value of the `filter` parameter.  For example you can
use `curl` like this;

    curl --data-urlencode "filter=attribute: value"

Common attributes:

* `name` - node name
* `tags` - tags
* `hostname`
* `username`
* `osFamily`, `osName`, `osVersion`, `osArch`

Custom attributes can also be used.

Authorization required: `read` for project resource type `node`, as well as `read` for each Node resource

Since: v14

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param project Project Name
 @return ApiApiResourcesv2Request
*/
func (a *ProjectAPIService) ApiResourcesv2(ctx context.Context, project string) ApiApiResourcesv2Request {
	return ApiApiResourcesv2Request{
		ApiService: a,
		ctx: ctx,
		project: project,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ProjectAPIService) ApiResourcesv2Execute(r ApiApiResourcesv2Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.ApiResourcesv2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project/{project}/resources"
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/yaml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["rundeckApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Rundeck-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiResourcev14Request struct {
	ctx context.Context
	ApiService *ProjectAPIService
	project string
	name string
}

func (r ApiApiResourcev14Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ApiResourcev14Execute(r)
}

/*
ApiResourcev14 Get Node Info

Get a specific resource within a project.

Authorization required: `read` for project resource type `node`, as well as `read` for the Node 

Since: v14

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param project Project Name
 @param name Node Name
 @return ApiApiResourcev14Request
*/
func (a *ProjectAPIService) ApiResourcev14(ctx context.Context, project string, name string) ApiApiResourcev14Request {
	return ApiApiResourcev14Request{
		ApiService: a,
		ctx: ctx,
		project: project,
		name: name,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ProjectAPIService) ApiResourcev14Execute(r ApiApiResourcev14Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.ApiResourcev14")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project/{project}/resource/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/yaml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["rundeckApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Rundeck-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiSourceGetRequest struct {
	ctx context.Context
	ApiService *ProjectAPIService
	project string
	index int32
}

func (r ApiApiSourceGetRequest) Execute() (*Source, *http.Response, error) {
	return r.ApiService.ApiSourceGetExecute(r)
}

/*
ApiSourceGet Get a Resource Model Source for a Project

The response contains the `index`, the `type`, and 
details about the `resources`. If the
source had any error, that is included as `errors`.

Resources data includes any `description` provided by the source, whether it is `empty`, and
whether it is `writeable`.  The `href` indicates the URL for `/project/{project}/source/{index}/resources`.

Authorization required: `configure` for project resource

Since: v23

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param project Project Name
 @param index Source Index
 @return ApiApiSourceGetRequest
*/
func (a *ProjectAPIService) ApiSourceGet(ctx context.Context, project string, index int32) ApiApiSourceGetRequest {
	return ApiApiSourceGetRequest{
		ApiService: a,
		ctx: ctx,
		project: project,
		index: index,
	}
}

// Execute executes the request
//  @return Source
func (a *ProjectAPIService) ApiSourceGetExecute(r ApiApiSourceGetRequest) (*Source, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Source
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.ApiSourceGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project/{project}/source/{index}"
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["rundeckApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Rundeck-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiSourceGetContentRequest struct {
	ctx context.Context
	ApiService *ProjectAPIService
	project string
	index int32
}

func (r ApiApiSourceGetContentRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ApiSourceGetContentExecute(r)
}

/*
ApiSourceGetContent List Resources of a Resource Model Source


Authorization required: `configure` for project resource

Since: v23

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param project Project Name
 @param index Source Index
 @return ApiApiSourceGetContentRequest
*/
func (a *ProjectAPIService) ApiSourceGetContent(ctx context.Context, project string, index int32) ApiApiSourceGetContentRequest {
	return ApiApiSourceGetContentRequest{
		ApiService: a,
		ctx: ctx,
		project: project,
		index: index,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ProjectAPIService) ApiSourceGetContentExecute(r ApiApiSourceGetContentRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.ApiSourceGetContent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project/{project}/source/{index}/resources"
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/yaml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["rundeckApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Rundeck-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiSourceWriteContentRequest struct {
	ctx context.Context
	ApiService *ProjectAPIService
	project string
	index int32
	body *map[string]interface{}
}

// Resource model data in the supported format
func (r ApiApiSourceWriteContentRequest) Body(body map[string]interface{}) ApiApiSourceWriteContentRequest {
	r.body = &body
	return r
}

func (r ApiApiSourceWriteContentRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ApiSourceWriteContentExecute(r)
}

/*
ApiSourceWriteContent Update Resources of a Resource Model Source


Authorization required: `configure` for project resource

Since: v23

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param project Project Name
 @param index Source Index
 @return ApiApiSourceWriteContentRequest
*/
func (a *ProjectAPIService) ApiSourceWriteContent(ctx context.Context, project string, index int32) ApiApiSourceWriteContentRequest {
	return ApiApiSourceWriteContentRequest{
		ApiService: a,
		ctx: ctx,
		project: project,
		index: index,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ProjectAPIService) ApiSourceWriteContentExecute(r ApiApiSourceWriteContentRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.ApiSourceWriteContent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project/{project}/source/{index}/resources"
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", url.PathEscape(parameterValueToString(r.index, "index")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/yaml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/yaml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["rundeckApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Rundeck-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiSourcesListRequest struct {
	ctx context.Context
	ApiService *ProjectAPIService
	project string
}

func (r ApiApiSourcesListRequest) Execute() ([]Source, *http.Response, error) {
	return r.ApiService.ApiSourcesListExecute(r)
}

/*
ApiSourcesList List Resource Model Sources for a Project

The response contains a set of `source` objects, each describes the `index`, the `type`, and 
details about the `resources`. If the
source had any error, that is included as `errors`.

Resources data includes any `description` provided by the source, whether it is `empty`, and
whether it is `writeable`.  The `href` indicates the URL for `/project/{project}/source/{index}/resources`.

Authorization required: `configure` for project resource

Since: v23

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param project Project Name
 @return ApiApiSourcesListRequest
*/
func (a *ProjectAPIService) ApiSourcesList(ctx context.Context, project string) ApiApiSourcesListRequest {
	return ApiApiSourcesListRequest{
		ApiService: a,
		ctx: ctx,
		project: project,
	}
}

// Execute executes the request
//  @return []Source
func (a *ProjectAPIService) ApiSourcesListExecute(r ApiApiSourcesListRequest) ([]Source, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Source
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.ApiSourcesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project/{project}/sources"
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["rundeckApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Rundeck-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiTagsForNodesRequest struct {
	ctx context.Context
	ApiService *ProjectAPIService
	project string
}

func (r ApiApiTagsForNodesRequest) Execute() (*TagsForNodesResponse, *http.Response, error) {
	return r.ApiService.ApiTagsForNodesExecute(r)
}

/*
ApiTagsForNodes List tags for project nodes

List tags for project nodes.

Since: v52

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param project Project Name
 @return ApiApiTagsForNodesRequest
*/
func (a *ProjectAPIService) ApiTagsForNodes(ctx context.Context, project string) ApiApiTagsForNodesRequest {
	return ApiApiTagsForNodesRequest{
		ApiService: a,
		ctx: ctx,
		project: project,
	}
}

// Execute executes the request
//  @return TagsForNodesResponse
func (a *ProjectAPIService) ApiTagsForNodesExecute(r ApiApiTagsForNodesRequest) (*TagsForNodesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TagsForNodesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProjectAPIService.ApiTagsForNodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project/{project}/nodes/tags"
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["rundeckApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Rundeck-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
