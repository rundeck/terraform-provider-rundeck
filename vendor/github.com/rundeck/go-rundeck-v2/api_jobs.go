/*
Rundeck

Rundeck provides a Web API for use with your applications.

API version: 53
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
	"time"
)


// JobsAPIService JobsAPI service
type JobsAPIService service

type ApiApiExecutionDataAvailableRequest struct {
	ctx context.Context
	ApiService *JobsAPIService
	id string
}

func (r ApiApiExecutionDataAvailableRequest) Execute() (*ResultDataAvailableResponse, *http.Response, error) {
	return r.ApiService.ApiExecutionDataAvailableExecute(r)
}

/*
ApiExecutionDataAvailable Check Execution Result Data Availability [Enterprise]

Check whether the execution has Result Data created by a Job using the [Result Data feature](https://docs.rundeck.com/docs/manual/execution-lifecycle/result-data.html).

Since: v40


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Execution ID
 @return ApiApiExecutionDataAvailableRequest
*/
func (a *JobsAPIService) ApiExecutionDataAvailable(ctx context.Context, id string) ApiApiExecutionDataAvailableRequest {
	return ApiApiExecutionDataAvailableRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ResultDataAvailableResponse
func (a *JobsAPIService) ApiExecutionDataAvailableExecute(r ApiApiExecutionDataAvailableRequest) (*ResultDataAvailableResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResultDataAvailableResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsAPIService.ApiExecutionDataAvailable")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/execution/{id}/result/dataAvailable"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["rundeckApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Rundeck-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResultDataBasicErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiExecutionDataExportRequest struct {
	ctx context.Context
	ApiService *JobsAPIService
	id string
	wait *bool
}

// if true and the data is not immediately available, the response will wait until the data is retrieved, or a timeout occurs. Otherwise the response may return 202 status if data must be retrieved first.
func (r ApiApiExecutionDataExportRequest) Wait(wait bool) ApiApiExecutionDataExportRequest {
	r.wait = &wait
	return r
}

func (r ApiApiExecutionDataExportRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiExecutionDataExportExecute(r)
}

/*
ApiExecutionDataExport Get Execution Result Data [Enterprise]

Retrieve the Result Data created by a Job using the [Result Data feature](https://docs.rundeck.com/docs/manual/execution-lifecycle/result-data.html) in JSON format.

Note: In a Rundeck Cluster, Result Data may not be locally available and must be retrieved by the server asynchronously before it can be returned.

You can handle this situation in two ways: either use the `wait=true` URL parameter, to indicate that the API request should block until the data is retrieved (waiting up to 10 seconds), or if the response has HTTP status 202 it means that the asynchronous request was started but has not completed yet and you can retry the same API request shortly.

Since: v40


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Execution ID
 @return ApiApiExecutionDataExportRequest
*/
func (a *JobsAPIService) ApiExecutionDataExport(ctx context.Context, id string) ApiApiExecutionDataExportRequest {
	return ApiApiExecutionDataExportRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *JobsAPIService) ApiExecutionDataExportExecute(r ApiApiExecutionDataExportRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsAPIService.ApiExecutionDataExport")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/execution/{id}/result/data"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.wait != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wait", r.wait, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["rundeckApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Rundeck-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResultDataBasicErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiFlipExecutionDisabledRequest struct {
	ctx context.Context
	ApiService *JobsAPIService
	id string
}

func (r ApiApiFlipExecutionDisabledRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ApiFlipExecutionDisabledExecute(r)
}

/*
ApiFlipExecutionDisabled Disable Executions for a Job

Disable executions for a job. 

Authorization required: `toggle_execution` action for a job.

Since: V14

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Job ID
 @return ApiApiFlipExecutionDisabledRequest
*/
func (a *JobsAPIService) ApiFlipExecutionDisabled(ctx context.Context, id string) ApiApiFlipExecutionDisabledRequest {
	return ApiApiFlipExecutionDisabledRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *JobsAPIService) ApiFlipExecutionDisabledExecute(r ApiApiFlipExecutionDisabledRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsAPIService.ApiFlipExecutionDisabled")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/job/{id}/execution/disable"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["rundeckApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Rundeck-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiFlipExecutionDisabledBulkRequest struct {
	ctx context.Context
	ApiService *JobsAPIService
	ids *[]string
	idlist *string
	apiBulkJobDeleteRequest *ApiBulkJobDeleteRequest
}

// The Job IDs to delete, can be specified multiple times
func (r ApiApiFlipExecutionDisabledBulkRequest) Ids(ids []string) ApiApiFlipExecutionDisabledBulkRequest {
	r.ids = &ids
	return r
}

// The Job IDs to delete as a single comma-separated string.
func (r ApiApiFlipExecutionDisabledBulkRequest) Idlist(idlist string) ApiApiFlipExecutionDisabledBulkRequest {
	r.idlist = &idlist
	return r
}

// request
func (r ApiApiFlipExecutionDisabledBulkRequest) ApiBulkJobDeleteRequest(apiBulkJobDeleteRequest ApiBulkJobDeleteRequest) ApiApiFlipExecutionDisabledBulkRequest {
	r.apiBulkJobDeleteRequest = &apiBulkJobDeleteRequest
	return r
}

func (r ApiApiFlipExecutionDisabledBulkRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ApiFlipExecutionDisabledBulkExecute(r)
}

/*
ApiFlipExecutionDisabledBulk Bulk Toggle Job Execution Disabled

Toggle executions disabled for a set of jobs.

Authorization required: `toggle_execution` action for each job.

Since: v16

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiFlipExecutionDisabledBulkRequest
*/
func (a *JobsAPIService) ApiFlipExecutionDisabledBulk(ctx context.Context) ApiApiFlipExecutionDisabledBulkRequest {
	return ApiApiFlipExecutionDisabledBulkRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *JobsAPIService) ApiFlipExecutionDisabledBulkExecute(r ApiApiFlipExecutionDisabledBulkRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsAPIService.ApiFlipExecutionDisabledBulk")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/jobs/execution/disable"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ids != nil {
		t := *r.ids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ids", t, "form", "multi")
		}
	}
	if r.idlist != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idlist", r.idlist, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.apiBulkJobDeleteRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["rundeckApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Rundeck-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiFlipExecutionEnabledRequest struct {
	ctx context.Context
	ApiService *JobsAPIService
	id string
}

func (r ApiApiFlipExecutionEnabledRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ApiFlipExecutionEnabledExecute(r)
}

/*
ApiFlipExecutionEnabled Enable Executions for a Job

Enable executions for a job. 

Authorization required: `toggle_execution` action for a job.

Since: V14

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Job ID
 @return ApiApiFlipExecutionEnabledRequest
*/
func (a *JobsAPIService) ApiFlipExecutionEnabled(ctx context.Context, id string) ApiApiFlipExecutionEnabledRequest {
	return ApiApiFlipExecutionEnabledRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *JobsAPIService) ApiFlipExecutionEnabledExecute(r ApiApiFlipExecutionEnabledRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsAPIService.ApiFlipExecutionEnabled")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/job/{id}/execution/enable"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["rundeckApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Rundeck-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiFlipExecutionEnabledBulkRequest struct {
	ctx context.Context
	ApiService *JobsAPIService
	ids *[]string
	idlist *string
	apiBulkJobDeleteRequest *ApiBulkJobDeleteRequest
}

// The Job IDs to delete, can be specified multiple times
func (r ApiApiFlipExecutionEnabledBulkRequest) Ids(ids []string) ApiApiFlipExecutionEnabledBulkRequest {
	r.ids = &ids
	return r
}

// The Job IDs to delete as a single comma-separated string.
func (r ApiApiFlipExecutionEnabledBulkRequest) Idlist(idlist string) ApiApiFlipExecutionEnabledBulkRequest {
	r.idlist = &idlist
	return r
}

// Bulk ID request
func (r ApiApiFlipExecutionEnabledBulkRequest) ApiBulkJobDeleteRequest(apiBulkJobDeleteRequest ApiBulkJobDeleteRequest) ApiApiFlipExecutionEnabledBulkRequest {
	r.apiBulkJobDeleteRequest = &apiBulkJobDeleteRequest
	return r
}

func (r ApiApiFlipExecutionEnabledBulkRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ApiFlipExecutionEnabledBulkExecute(r)
}

/*
ApiFlipExecutionEnabledBulk Bulk Toggle Job Execution Enabled

Toggle executions enabled for a set of jobs.

Authorization required: `toggle_execution` action for each job.

Since: v16

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiFlipExecutionEnabledBulkRequest
*/
func (a *JobsAPIService) ApiFlipExecutionEnabledBulk(ctx context.Context) ApiApiFlipExecutionEnabledBulkRequest {
	return ApiApiFlipExecutionEnabledBulkRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *JobsAPIService) ApiFlipExecutionEnabledBulkExecute(r ApiApiFlipExecutionEnabledBulkRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsAPIService.ApiFlipExecutionEnabledBulk")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/jobs/execution/enable"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ids != nil {
		t := *r.ids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ids", t, "form", "multi")
		}
	}
	if r.idlist != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idlist", r.idlist, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.apiBulkJobDeleteRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["rundeckApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Rundeck-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiFlipScheduleDisabledRequest struct {
	ctx context.Context
	ApiService *JobsAPIService
	id string
}

func (r ApiApiFlipScheduleDisabledRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ApiFlipScheduleDisabledExecute(r)
}

/*
ApiFlipScheduleDisabled Disable Schedule for a Job

Disable schedule for a job. 

Authorization required: `toggle_schedule` action for a job.

Since: V14

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Job ID
 @return ApiApiFlipScheduleDisabledRequest
*/
func (a *JobsAPIService) ApiFlipScheduleDisabled(ctx context.Context, id string) ApiApiFlipScheduleDisabledRequest {
	return ApiApiFlipScheduleDisabledRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *JobsAPIService) ApiFlipScheduleDisabledExecute(r ApiApiFlipScheduleDisabledRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsAPIService.ApiFlipScheduleDisabled")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/job/{id}/schedule/disable"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["rundeckApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Rundeck-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiFlipScheduleDisabledBulkRequest struct {
	ctx context.Context
	ApiService *JobsAPIService
	ids *[]string
	idlist *string
	apiBulkJobDeleteRequest *ApiBulkJobDeleteRequest
}

// The Job IDs to delete, can be specified multiple times
func (r ApiApiFlipScheduleDisabledBulkRequest) Ids(ids []string) ApiApiFlipScheduleDisabledBulkRequest {
	r.ids = &ids
	return r
}

// The Job IDs to delete as a single comma-separated string.
func (r ApiApiFlipScheduleDisabledBulkRequest) Idlist(idlist string) ApiApiFlipScheduleDisabledBulkRequest {
	r.idlist = &idlist
	return r
}

// Bulk ID request
func (r ApiApiFlipScheduleDisabledBulkRequest) ApiBulkJobDeleteRequest(apiBulkJobDeleteRequest ApiBulkJobDeleteRequest) ApiApiFlipScheduleDisabledBulkRequest {
	r.apiBulkJobDeleteRequest = &apiBulkJobDeleteRequest
	return r
}

func (r ApiApiFlipScheduleDisabledBulkRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ApiFlipScheduleDisabledBulkExecute(r)
}

/*
ApiFlipScheduleDisabledBulk Bulk Toggle Job Schedule Disabled

Toggle schedule disabled for a set of jobs.

Authorization required: `toggle_schedule` action for each job.

Since: v16

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiFlipScheduleDisabledBulkRequest
*/
func (a *JobsAPIService) ApiFlipScheduleDisabledBulk(ctx context.Context) ApiApiFlipScheduleDisabledBulkRequest {
	return ApiApiFlipScheduleDisabledBulkRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *JobsAPIService) ApiFlipScheduleDisabledBulkExecute(r ApiApiFlipScheduleDisabledBulkRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsAPIService.ApiFlipScheduleDisabledBulk")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/jobs/schedule/disable"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ids != nil {
		t := *r.ids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ids", t, "form", "multi")
		}
	}
	if r.idlist != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idlist", r.idlist, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.apiBulkJobDeleteRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["rundeckApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Rundeck-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiFlipScheduleEnabledRequest struct {
	ctx context.Context
	ApiService *JobsAPIService
	id string
}

func (r ApiApiFlipScheduleEnabledRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ApiFlipScheduleEnabledExecute(r)
}

/*
ApiFlipScheduleEnabled Enable Schedule for a Job

Enable schedule for a job. 

Authorization required: `toggle_schedule` action for a job.

Since: V14

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Job ID
 @return ApiApiFlipScheduleEnabledRequest
*/
func (a *JobsAPIService) ApiFlipScheduleEnabled(ctx context.Context, id string) ApiApiFlipScheduleEnabledRequest {
	return ApiApiFlipScheduleEnabledRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *JobsAPIService) ApiFlipScheduleEnabledExecute(r ApiApiFlipScheduleEnabledRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsAPIService.ApiFlipScheduleEnabled")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/job/{id}/schedule/enable"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["rundeckApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Rundeck-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiFlipScheduleEnabledBulkRequest struct {
	ctx context.Context
	ApiService *JobsAPIService
	ids *[]string
	idlist *string
	apiBulkJobDeleteRequest *ApiBulkJobDeleteRequest
}

// The Job IDs to delete, can be specified multiple times
func (r ApiApiFlipScheduleEnabledBulkRequest) Ids(ids []string) ApiApiFlipScheduleEnabledBulkRequest {
	r.ids = &ids
	return r
}

// The Job IDs to delete as a single comma-separated string.
func (r ApiApiFlipScheduleEnabledBulkRequest) Idlist(idlist string) ApiApiFlipScheduleEnabledBulkRequest {
	r.idlist = &idlist
	return r
}

// Bulk ID request
func (r ApiApiFlipScheduleEnabledBulkRequest) ApiBulkJobDeleteRequest(apiBulkJobDeleteRequest ApiBulkJobDeleteRequest) ApiApiFlipScheduleEnabledBulkRequest {
	r.apiBulkJobDeleteRequest = &apiBulkJobDeleteRequest
	return r
}

func (r ApiApiFlipScheduleEnabledBulkRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ApiFlipScheduleEnabledBulkExecute(r)
}

/*
ApiFlipScheduleEnabledBulk Bulk Toggle Job Schedule Enabled

Toggle schedule enabled for a set of jobs.

Authorization required: `toggle_schedule` action for each job.

Since: v16

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiFlipScheduleEnabledBulkRequest
*/
func (a *JobsAPIService) ApiFlipScheduleEnabledBulk(ctx context.Context) ApiApiFlipScheduleEnabledBulkRequest {
	return ApiApiFlipScheduleEnabledBulkRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *JobsAPIService) ApiFlipScheduleEnabledBulkExecute(r ApiApiFlipScheduleEnabledBulkRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsAPIService.ApiFlipScheduleEnabledBulk")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/jobs/schedule/enable"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ids != nil {
		t := *r.ids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ids", t, "form", "multi")
		}
	}
	if r.idlist != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idlist", r.idlist, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.apiBulkJobDeleteRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["rundeckApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Rundeck-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiJobBrowseRequest struct {
	ctx context.Context
	ApiService *JobsAPIService
	project string
	path *string
	meta *string
	breakpoint *int32
	rdJobQueryInput *RdJobQueryInput
}

// Group path root, or blank for the root
func (r ApiApiJobBrowseRequest) Path(path string) ApiApiJobBrowseRequest {
	r.path = &path
	return r
}

// Comma-separated list of metadata items to include, or \&quot;*\&quot; for all
func (r ApiApiJobBrowseRequest) Meta(meta string) ApiApiJobBrowseRequest {
	r.meta = &meta
	return r
}

// Breakpoint, max number of jobs to load with metadata, if more results than the  breakpoint are available, no metadata will be loaded
func (r ApiApiJobBrowseRequest) Breakpoint(breakpoint int32) ApiApiJobBrowseRequest {
	r.breakpoint = &breakpoint
	return r
}

// Query parameters
func (r ApiApiJobBrowseRequest) RdJobQueryInput(rdJobQueryInput RdJobQueryInput) ApiApiJobBrowseRequest {
	r.rdJobQueryInput = &rdJobQueryInput
	return r
}

func (r ApiApiJobBrowseRequest) Execute() (*JobBrowseResponse, *http.Response, error) {
	return r.ApiService.ApiJobBrowseExecute(r)
}

/*
ApiJobBrowse Project Job Group browse

Query the jobs at a specific group path. Response includes the list of immediate jobs matching the query in the exact path, 
and the names of job Groups starting at that path.

Authorization required: `read` or `view` for the Jobs.

Since: v46

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param project Project name
 @return ApiApiJobBrowseRequest
*/
func (a *JobsAPIService) ApiJobBrowse(ctx context.Context, project string) ApiApiJobBrowseRequest {
	return ApiApiJobBrowseRequest{
		ApiService: a,
		ctx: ctx,
		project: project,
	}
}

// Execute executes the request
//  @return JobBrowseResponse
func (a *JobsAPIService) ApiJobBrowseExecute(r ApiApiJobBrowseRequest) (*JobBrowseResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *JobBrowseResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsAPIService.ApiJobBrowse")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project/{project}/jobs/browse"
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.path == nil {
		return localVarReturnValue, nil, reportError("path is required and must be specified")
	}
	if r.meta == nil {
		return localVarReturnValue, nil, reportError("meta is required and must be specified")
	}
	if r.breakpoint == nil {
		return localVarReturnValue, nil, reportError("breakpoint is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "path", r.path, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "meta", r.meta, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "breakpoint", r.breakpoint, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.rdJobQueryInput
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["rundeckApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Rundeck-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiJobBrowseGetDocsRequest struct {
	ctx context.Context
	ApiService *JobsAPIService
	project string
	path *string
	meta *string
	breakpoint *int32
}

// Group path root, or blank for the root
func (r ApiApiJobBrowseGetDocsRequest) Path(path string) ApiApiJobBrowseGetDocsRequest {
	r.path = &path
	return r
}

// Comma-separated list of metadata items to include, or \&quot;*\&quot; for all
func (r ApiApiJobBrowseGetDocsRequest) Meta(meta string) ApiApiJobBrowseGetDocsRequest {
	r.meta = &meta
	return r
}

// Breakpoint, max number of jobs to load with metadata, if more results than the  breakpoint are available, no metadata will be loaded
func (r ApiApiJobBrowseGetDocsRequest) Breakpoint(breakpoint int32) ApiApiJobBrowseGetDocsRequest {
	r.breakpoint = &breakpoint
	return r
}

func (r ApiApiJobBrowseGetDocsRequest) Execute() (*JobBrowseResponse, *http.Response, error) {
	return r.ApiService.ApiJobBrowseGetDocsExecute(r)
}

/*
ApiJobBrowseGetDocs Browse jobs at a path

Browse the jobs at a specific group path.

Authorization required: `read` or `view` for the Job.

Since: v46

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param project Project name
 @return ApiApiJobBrowseGetDocsRequest
*/
func (a *JobsAPIService) ApiJobBrowseGetDocs(ctx context.Context, project string) ApiApiJobBrowseGetDocsRequest {
	return ApiApiJobBrowseGetDocsRequest{
		ApiService: a,
		ctx: ctx,
		project: project,
	}
}

// Execute executes the request
//  @return JobBrowseResponse
func (a *JobsAPIService) ApiJobBrowseGetDocsExecute(r ApiApiJobBrowseGetDocsRequest) (*JobBrowseResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *JobBrowseResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsAPIService.ApiJobBrowseGetDocs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project/{project}/jobs/browse"
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.path == nil {
		return localVarReturnValue, nil, reportError("path is required and must be specified")
	}
	if r.meta == nil {
		return localVarReturnValue, nil, reportError("meta is required and must be specified")
	}
	if r.breakpoint == nil {
		return localVarReturnValue, nil, reportError("breakpoint is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "path", r.path, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "meta", r.meta, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "breakpoint", r.breakpoint, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["rundeckApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Rundeck-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiJobDeleteRequest struct {
	ctx context.Context
	ApiService *JobsAPIService
	id string
}

func (r ApiApiJobDeleteRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ApiJobDeleteExecute(r)
}

/*
ApiJobDelete Deleting a Job Definition

Delete a single job definition.

Authorization required: `delete` for the job.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Job ID
 @return ApiApiJobDeleteRequest
*/
func (a *JobsAPIService) ApiJobDelete(ctx context.Context, id string) ApiApiJobDeleteRequest {
	return ApiApiJobDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *JobsAPIService) ApiJobDeleteExecute(r ApiApiJobDeleteRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsAPIService.ApiJobDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/job/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["rundeckApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Rundeck-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiJobDeleteBulkRequest struct {
	ctx context.Context
	ApiService *JobsAPIService
	apiBulkJobDeleteRequest *ApiBulkJobDeleteRequest
}

// Bulk ID request
func (r ApiApiJobDeleteBulkRequest) ApiBulkJobDeleteRequest(apiBulkJobDeleteRequest ApiBulkJobDeleteRequest) ApiApiJobDeleteBulkRequest {
	r.apiBulkJobDeleteRequest = &apiBulkJobDeleteRequest
	return r
}

func (r ApiApiJobDeleteBulkRequest) Execute() (*DeleteBulkResponse, *http.Response, error) {
	return r.ApiService.ApiJobDeleteBulkExecute(r)
}

/*
ApiJobDeleteBulk Bulk Job Delete

Delete multiple job definitions at once.

Both `DELETE` and `POST` are allowed for doing a bulk delete of jobs. 
However, to send a body with the request, 
then the POST method must be used, 
since the DELETE method does not allow for request bodies.
 
Authorization required: `delete` on project resource type `job`, and `delete` on each Job resource.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiJobDeleteBulkRequest
*/
func (a *JobsAPIService) ApiJobDeleteBulk(ctx context.Context) ApiApiJobDeleteBulkRequest {
	return ApiApiJobDeleteBulkRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DeleteBulkResponse
func (a *JobsAPIService) ApiJobDeleteBulkExecute(r ApiApiJobDeleteBulkRequest) (*DeleteBulkResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeleteBulkResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsAPIService.ApiJobDeleteBulk")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/jobs/delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.apiBulkJobDeleteRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["rundeckApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Rundeck-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiJobDeleteBulkDocs2Request struct {
	ctx context.Context
	ApiService *JobsAPIService
	ids *[]string
	idlist *string
}

// The Job IDs to delete, can be specified multiple times
func (r ApiApiJobDeleteBulkDocs2Request) Ids(ids []string) ApiApiJobDeleteBulkDocs2Request {
	r.ids = &ids
	return r
}

// The Job IDs to delete as a single comma-separated string.
func (r ApiApiJobDeleteBulkDocs2Request) Idlist(idlist string) ApiApiJobDeleteBulkDocs2Request {
	r.idlist = &idlist
	return r
}

func (r ApiApiJobDeleteBulkDocs2Request) Execute() (*DeleteBulkResponse, *http.Response, error) {
	return r.ApiService.ApiJobDeleteBulkDocs2Execute(r)
}

/*
ApiJobDeleteBulkDocs2 Bulk Job Delete

Delete multiple job definitions at once.

Both `DELETE` and `POST` are allowed for doing a bulk delete of jobs. 
However, to send a body with the request, 
then the POST method must be used, 
since the DELETE method does not allow for request bodies.
 
Authorization required: `delete` on project resource type `job`, and `delete` on each Job resource.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiJobDeleteBulkDocs2Request
*/
func (a *JobsAPIService) ApiJobDeleteBulkDocs2(ctx context.Context) ApiApiJobDeleteBulkDocs2Request {
	return ApiApiJobDeleteBulkDocs2Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DeleteBulkResponse
func (a *JobsAPIService) ApiJobDeleteBulkDocs2Execute(r ApiApiJobDeleteBulkDocs2Request) (*DeleteBulkResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeleteBulkResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsAPIService.ApiJobDeleteBulkDocs2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/jobs/delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ids != nil {
		t := *r.ids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ids", t, "form", "multi")
		}
	}
	if r.idlist != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idlist", r.idlist, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["rundeckApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Rundeck-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiJobDetailRequest struct {
	ctx context.Context
	ApiService *JobsAPIService
	id string
}

func (r ApiApiJobDetailRequest) Execute() (*JobInfo, *http.Response, error) {
	return r.ApiService.ApiJobDetailExecute(r)
}

/*
ApiJobDetail Get Job Metadata

Get metadata about a specific job.

Authorization required: `read` or `view` for the job.

Since: V18

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Job ID
 @return ApiApiJobDetailRequest
*/
func (a *JobsAPIService) ApiJobDetail(ctx context.Context, id string) ApiApiJobDetailRequest {
	return ApiApiJobDetailRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return JobInfo
func (a *JobsAPIService) ApiJobDetailExecute(r ApiApiJobDetailRequest) (*JobInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *JobInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsAPIService.ApiJobDetail")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/job/{id}/info"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["rundeckApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Rundeck-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiJobExecutionsRequest struct {
	ctx context.Context
	ApiService *JobsAPIService
	id string
	status *string
	max *int32
	offset *int32
	includeJobRef *bool
}

// the status of executions you want to be returned.  Must be  one of \&quot;succeeded\&quot;, \&quot;failed\&quot;, \&quot;aborted\&quot;, or \&quot;running\&quot;.  If this parameter is blank or unset, include all executions.
func (r ApiApiJobExecutionsRequest) Status(status string) ApiApiJobExecutionsRequest {
	r.status = &status
	return r
}

// indicate the maximum number of results to return. If  unspecified, all results will be returned
func (r ApiApiJobExecutionsRequest) Max(max int32) ApiApiJobExecutionsRequest {
	r.max = &max
	return r
}

// indicate the 0-indexed offset for the first result to  return.
func (r ApiApiJobExecutionsRequest) Offset(offset int32) ApiApiJobExecutionsRequest {
	r.offset = &offset
	return r
}

// if true, include executions from the job reference in the results. Default is false.  Requires API version 50 or later.
func (r ApiApiJobExecutionsRequest) IncludeJobRef(includeJobRef bool) ApiApiJobExecutionsRequest {
	r.includeJobRef = &includeJobRef
	return r
}

func (r ApiApiJobExecutionsRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.ApiJobExecutionsExecute(r)
}

/*
ApiJobExecutions Getting Executions for a Job

Get the list of executions for a Job.

Authorizations required: `read` or `view` for the Job, and `read` for the project resource type `execution`.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Job ID
 @return ApiApiJobExecutionsRequest
*/
func (a *JobsAPIService) ApiJobExecutions(ctx context.Context, id string) ApiApiJobExecutionsRequest {
	return ApiApiJobExecutionsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *JobsAPIService) ApiJobExecutionsExecute(r ApiApiJobExecutionsRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsAPIService.ApiJobExecutions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/job/{id}/executions"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	}
	if r.max != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max", r.max, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.includeJobRef != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeJobRef", r.includeJobRef, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["rundeckApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Rundeck-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiJobExecutionsDeleteRequest struct {
	ctx context.Context
	ApiService *JobsAPIService
	id string
}

func (r ApiApiJobExecutionsDeleteRequest) Execute() (*DeleteBulkResponse, *http.Response, error) {
	return r.ApiService.ApiJobExecutionsDeleteExecute(r)
}

/*
ApiJobExecutionsDelete Delete all Executions for a Job

Delete all executions for a Job.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Job ID
 @return ApiApiJobExecutionsDeleteRequest
*/
func (a *JobsAPIService) ApiJobExecutionsDelete(ctx context.Context, id string) ApiApiJobExecutionsDeleteRequest {
	return ApiApiJobExecutionsDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return DeleteBulkResponse
func (a *JobsAPIService) ApiJobExecutionsDeleteExecute(r ApiApiJobExecutionsDeleteRequest) (*DeleteBulkResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeleteBulkResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsAPIService.ApiJobExecutionsDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/job/{id}/executions"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["rundeckApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Rundeck-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiJobExportRequest struct {
	ctx context.Context
	ApiService *JobsAPIService
	id string
	format *string
}

// can be \&quot;yaml\&quot; or \&quot;json\&quot; (API v44+) to specify the output format
func (r ApiApiJobExportRequest) Format(format string) ApiApiJobExportRequest {
	r.format = &format
	return r
}

func (r ApiApiJobExportRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ApiJobExportExecute(r)
}

/*
ApiJobExport Getting a Job Definition

Export a single job definition, in one of the supported formats.

Authorization required: `read` for the Job.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Job ID
 @return ApiApiJobExportRequest
*/
func (a *JobsAPIService) ApiJobExport(ctx context.Context, id string) ApiApiJobExportRequest {
	return ApiApiJobExportRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *JobsAPIService) ApiJobExportExecute(r ApiApiJobExportRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsAPIService.ApiJobExport")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/job/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/yaml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["rundeckApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Rundeck-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 415 {
			var v ApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiJobFileInfoRequest struct {
	ctx context.Context
	ApiService *JobsAPIService
	id string
}

func (r ApiApiJobFileInfoRequest) Execute() (*JobFileInfo, *http.Response, error) {
	return r.ApiService.ApiJobFileInfoExecute(r)
}

/*
ApiJobFileInfo Get Info About an Uploaded File

Get info about an uploaded file given its ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id File ID
 @return ApiApiJobFileInfoRequest
*/
func (a *JobsAPIService) ApiJobFileInfo(ctx context.Context, id string) ApiApiJobFileInfoRequest {
	return ApiApiJobFileInfoRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return JobFileInfo
func (a *JobsAPIService) ApiJobFileInfoExecute(r ApiApiJobFileInfoRequest) (*JobFileInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *JobFileInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsAPIService.ApiJobFileInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/jobs/file/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["rundeckApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Rundeck-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiJobFileMultiUploadRequest struct {
	ctx context.Context
	ApiService *JobsAPIService
	id string
}

func (r ApiApiJobFileMultiUploadRequest) Execute() (*JobFileUpload, *http.Response, error) {
	return r.ApiService.ApiJobFileMultiUploadExecute(r)
}

/*
ApiJobFileMultiUpload Upload Multiple Files for Job Options

Job Options of type `file` require a file input. You can upload multiple files en-masse.

Each uploaded file is assigned a unique "file key" identifier.
You can then Run the Job using the "file key" as the option value.

For multiple files, use a Multi-part request.  For each file, specify the field name as `option.NAME` where NAME
is the option name. The filename is specified normally within the multi-part request.

Since: v19

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Job ID
 @return ApiApiJobFileMultiUploadRequest
*/
func (a *JobsAPIService) ApiJobFileMultiUpload(ctx context.Context, id string) ApiApiJobFileMultiUploadRequest {
	return ApiApiJobFileMultiUploadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return JobFileUpload
func (a *JobsAPIService) ApiJobFileMultiUploadExecute(r ApiApiJobFileMultiUploadRequest) (*JobFileUpload, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *JobFileUpload
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsAPIService.ApiJobFileMultiUpload")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/job/{id}/input/file"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["rundeckApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Rundeck-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiJobFileUploadRequest struct {
	ctx context.Context
	ApiService *JobsAPIService
	id string
	optionName string
	fileName *string
}

// Specify the original file name (optional)
func (r ApiApiJobFileUploadRequest) FileName(fileName string) ApiApiJobFileUploadRequest {
	r.fileName = &fileName
	return r
}

func (r ApiApiJobFileUploadRequest) Execute() (*JobFileUpload, *http.Response, error) {
	return r.ApiService.ApiJobFileUploadExecute(r)
}

/*
ApiJobFileUpload Upload a File for a Job Option

Job Options of type `file` require a file input. This endpoint uploads a single file individually.

Each uploaded file is assigned a unique "file key" identifier.
You can then Run the Job using the "file key" as the option value.

Since: v19

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Job ID
 @param optionName For a single file/option value, specify the option name either as a query parameter or as part of the URL path
 @return ApiApiJobFileUploadRequest
*/
func (a *JobsAPIService) ApiJobFileUpload(ctx context.Context, id string, optionName string) ApiApiJobFileUploadRequest {
	return ApiApiJobFileUploadRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		optionName: optionName,
	}
}

// Execute executes the request
//  @return JobFileUpload
func (a *JobsAPIService) ApiJobFileUploadExecute(r ApiApiJobFileUploadRequest) (*JobFileUpload, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *JobFileUpload
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsAPIService.ApiJobFileUpload")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/job/{id}/input/file/{optionName}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"optionName"+"}", url.PathEscape(parameterValueToString(r.optionName, "optionName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fileName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fileName", r.fileName, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/octet-stream"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["rundeckApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Rundeck-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiJobForecastRequest struct {
	ctx context.Context
	ApiService *JobsAPIService
	id string
	time *string
	past *bool
	max *int32
}

// Time range to forecast.   Format is a string like &#x60;2d1h4n5s&#x60; using the following characters for time units: * &#x60;s&#x60; second * &#x60;n&#x60; minute * &#x60;h&#x60; hour * &#x60;d&#x60; day * &#x60;w&#x60; week * &#x60;m&#x60; month * &#x60;y&#x60; year 
func (r ApiApiJobForecastRequest) Time(time string) ApiApiJobForecastRequest {
	r.time = &time
	return r
}

// Whether to return results in the past. default: false
func (r ApiApiJobForecastRequest) Past(past bool) ApiApiJobForecastRequest {
	r.past = &past
	return r
}

// Maximum number of results to return
func (r ApiApiJobForecastRequest) Max(max int32) ApiApiJobForecastRequest {
	r.max = &max
	return r
}

func (r ApiApiJobForecastRequest) Execute() (*JobInfo, *http.Response, error) {
	return r.ApiService.ApiJobForecastExecute(r)
}

/*
ApiJobForecast Get Job Forecast

Get Metadata for the job including a schedule forecast for a specific amount of time of the job by ID.
(**API v48** or later): forecast includes information about one time scheduled execution, and information if the project related to the job allows executions and scheduling

Authorization required: `read` or `view` for the Job

Since: V31

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Job ID
 @return ApiApiJobForecastRequest
*/
func (a *JobsAPIService) ApiJobForecast(ctx context.Context, id string) ApiApiJobForecastRequest {
	return ApiApiJobForecastRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return JobInfo
func (a *JobsAPIService) ApiJobForecastExecute(r ApiApiJobForecastRequest) (*JobInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *JobInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsAPIService.ApiJobForecast")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/job/{id}/forecast"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.time != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time", r.time, "form", "")
	}
	if r.past != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "past", r.past, "form", "")
	}
	if r.max != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max", r.max, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["rundeckApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Rundeck-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiJobMetaRequest struct {
	ctx context.Context
	ApiService *JobsAPIService
	id string
	meta *string
}

// Comma-separated list of metadata item names to include, or \&quot;*\&quot; for all (default)
func (r ApiApiJobMetaRequest) Meta(meta string) ApiApiJobMetaRequest {
	r.meta = &meta
	return r
}

func (r ApiApiJobMetaRequest) Execute() ([]ItemMeta, *http.Response, error) {
	return r.ApiService.ApiJobMetaExecute(r)
}

/*
ApiJobMeta Get Job UI Metadata

Get metadata for a specific job.

Authorization required: `read` or `view` for the Job.

Since: v46

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Job ID
 @return ApiApiJobMetaRequest
*/
func (a *JobsAPIService) ApiJobMeta(ctx context.Context, id string) ApiApiJobMetaRequest {
	return ApiApiJobMetaRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return []ItemMeta
func (a *JobsAPIService) ApiJobMetaExecute(r ApiApiJobMetaRequest) ([]ItemMeta, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ItemMeta
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsAPIService.ApiJobMeta")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/job/{id}/meta"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.meta == nil {
		return localVarReturnValue, nil, reportError("meta is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "meta", r.meta, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["rundeckApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Rundeck-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiJobRetryRequest struct {
	ctx context.Context
	ApiService *JobsAPIService
	id string
	executionId string
	failedNodes *bool
	argString *string
	loglevel *string
	asUser *string
	filter *string
	runAtTime *time.Time
	optionOPTNAME *string
	metaKEY *string
	body *map[string]interface{}
}

// &#x60;false&#x60; to run on the same nodes as the original execution, &#x60;true&#x60;or empty to run only on failed nodes.
func (r ApiApiJobRetryRequest) FailedNodes(failedNodes bool) ApiApiJobRetryRequest {
	r.failedNodes = &failedNodes
	return r
}

// argument string to pass to the job, of the form: &#x60;-opt value -opt2 value ...&#x60;.
func (r ApiApiJobRetryRequest) ArgString(argString string) ApiApiJobRetryRequest {
	r.argString = &argString
	return r
}

// argument specifying the loglevel to use
func (r ApiApiJobRetryRequest) Loglevel(loglevel string) ApiApiJobRetryRequest {
	r.loglevel = &loglevel
	return r
}

// specifies a username identifying the user who ran the job. Requires &#x60;runAs&#x60; permission.
func (r ApiApiJobRetryRequest) AsUser(asUser string) ApiApiJobRetryRequest {
	r.asUser = &asUser
	return r
}

// can be a node filter string.
func (r ApiApiJobRetryRequest) Filter(filter string) ApiApiJobRetryRequest {
	r.filter = &filter
	return r
}

// Specify a time to run the job (Since: v18).  This is a ISO-8601 date and time stamp with timezone, with optional milliseconds., e.g. &#x60;2016-11-23T12:20:55-0800&#x60; or &#x60;2016-11-23T12:20:55.123-0800&#x60;
func (r ApiApiJobRetryRequest) RunAtTime(runAtTime time.Time) ApiApiJobRetryRequest {
	r.runAtTime = &runAtTime
	return r
}

// Option value for option named &#x60;OPTNAME&#x60;. If any &#x60;option.OPTNAME&#x60; parameters are specified, the &#x60;argString&#x60; value is ignored (Since: v18).
func (r ApiApiJobRetryRequest) OptionOPTNAME(optionOPTNAME string) ApiApiJobRetryRequest {
	r.optionOPTNAME = &optionOPTNAME
	return r
}

// Additional metadata keyd by &#x60;KEY&#x60;. (Since: v32).
func (r ApiApiJobRetryRequest) MetaKEY(metaKEY string) ApiApiJobRetryRequest {
	r.metaKEY = &metaKEY
	return r
}

// Parameters can be specified in the request body, instead of as query parameters.  (**API v18** or later): The &#x60;options&#x60; entry can contain a map of option name -&gt; value, in which case the &#x60;argString&#x60; is ignored.
func (r ApiApiJobRetryRequest) Body(body map[string]interface{}) ApiApiJobRetryRequest {
	r.body = &body
	return r
}

func (r ApiApiJobRetryRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiJobRetryExecute(r)
}

/*
ApiJobRetry Retry a Job based on execution

Retry a failed execution on failed nodes only or on the same as the execution.
This is the same functionality as the `Retry Failed Nodes ...` button on the execution page.

Parameters can be specified in the request body, instead of as query parameters

Authorization required: `run` for the Job resource, and `read` or `view` for the Execution resource.

Since: v24


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Job ID
 @param executionId Execution ID
 @return ApiApiJobRetryRequest
*/
func (a *JobsAPIService) ApiJobRetry(ctx context.Context, id string, executionId string) ApiApiJobRetryRequest {
	return ApiApiJobRetryRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		executionId: executionId,
	}
}

// Execute executes the request
func (a *JobsAPIService) ApiJobRetryExecute(r ApiApiJobRetryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsAPIService.ApiJobRetry")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/job/{id}/retry/{executionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"executionId"+"}", url.PathEscape(parameterValueToString(r.executionId, "executionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.failedNodes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "failedNodes", r.failedNodes, "form", "")
	}
	if r.argString != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "argString", r.argString, "form", "")
	}
	if r.loglevel != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "loglevel", r.loglevel, "form", "")
	}
	if r.asUser != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "asUser", r.asUser, "form", "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "form", "")
	}
	if r.runAtTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "runAtTime", r.runAtTime, "form", "")
	}
	if r.optionOPTNAME != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "option.OPTNAME", r.optionOPTNAME, "form", "")
	}
	if r.metaKEY != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "meta.KEY", r.metaKEY, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["rundeckApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Rundeck-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiJobRunRequest struct {
	ctx context.Context
	ApiService *JobsAPIService
	id string
	argString *string
	loglevel *string
	asUser *string
	filter *string
	runAtTime *time.Time
	optionOPTNAME *string
	metaKEY *string
	body *map[string]interface{}
}

// argument string to pass to the job, of the form: &#x60;-opt value -opt2 value ...&#x60;.
func (r ApiApiJobRunRequest) ArgString(argString string) ApiApiJobRunRequest {
	r.argString = &argString
	return r
}

// argument specifying the loglevel to use
func (r ApiApiJobRunRequest) Loglevel(loglevel string) ApiApiJobRunRequest {
	r.loglevel = &loglevel
	return r
}

// specifies a username identifying the user who ran the job. Requires &#x60;runAs&#x60; permission.
func (r ApiApiJobRunRequest) AsUser(asUser string) ApiApiJobRunRequest {
	r.asUser = &asUser
	return r
}

// can be a node filter string.
func (r ApiApiJobRunRequest) Filter(filter string) ApiApiJobRunRequest {
	r.filter = &filter
	return r
}

// Specify a time to run the job (Since: v18).  This is a ISO-8601 date and time stamp with timezone, with optional milliseconds., e.g. &#x60;2016-11-23T12:20:55-0800&#x60; or &#x60;2016-11-23T12:20:55.123-0800&#x60;
func (r ApiApiJobRunRequest) RunAtTime(runAtTime time.Time) ApiApiJobRunRequest {
	r.runAtTime = &runAtTime
	return r
}

// Option value for option named &#x60;OPTNAME&#x60;. If any &#x60;option.OPTNAME&#x60; parameters are specified, the &#x60;argString&#x60; value is ignored (Since: v18).
func (r ApiApiJobRunRequest) OptionOPTNAME(optionOPTNAME string) ApiApiJobRunRequest {
	r.optionOPTNAME = &optionOPTNAME
	return r
}

// Additional metadata keyd by &#x60;KEY&#x60;. (Since: v32).
func (r ApiApiJobRunRequest) MetaKEY(metaKEY string) ApiApiJobRunRequest {
	r.metaKEY = &metaKEY
	return r
}

// Parameters can be specified in the request body, instead of as query parameters.  (**API v18** or later): The &#x60;options&#x60; entry can contain a map of option name -&gt; value, in which case the &#x60;argString&#x60; is ignored.
func (r ApiApiJobRunRequest) Body(body map[string]interface{}) ApiApiJobRunRequest {
	r.body = &body
	return r
}

func (r ApiApiJobRunRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiJobRunExecute(r)
}

/*
ApiJobRun Running a Job

Run a job specified by ID.

Parameters can be specified in the request body, instead of as query parameters

Authorization required: `run` for the Job resource.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Job ID
 @return ApiApiJobRunRequest
*/
func (a *JobsAPIService) ApiJobRun(ctx context.Context, id string) ApiApiJobRunRequest {
	return ApiApiJobRunRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *JobsAPIService) ApiJobRunExecute(r ApiApiJobRunRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsAPIService.ApiJobRun")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/job/{id}/executions"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.argString != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "argString", r.argString, "form", "")
	}
	if r.loglevel != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "loglevel", r.loglevel, "form", "")
	}
	if r.asUser != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "asUser", r.asUser, "form", "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "form", "")
	}
	if r.runAtTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "runAtTime", r.runAtTime, "form", "")
	}
	if r.optionOPTNAME != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "option.OPTNAME", r.optionOPTNAME, "form", "")
	}
	if r.metaKEY != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "meta.KEY", r.metaKEY, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["rundeckApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Rundeck-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiJobRun1Request struct {
	ctx context.Context
	ApiService *JobsAPIService
	id string
	argString *string
	loglevel *string
	asUser *string
	filter *string
	runAtTime *time.Time
	optionOPTNAME *string
	metaKEY *string
	body *map[string]interface{}
}

// argument string to pass to the job, of the form: &#x60;-opt value -opt2 value ...&#x60;.
func (r ApiApiJobRun1Request) ArgString(argString string) ApiApiJobRun1Request {
	r.argString = &argString
	return r
}

// argument specifying the loglevel to use
func (r ApiApiJobRun1Request) Loglevel(loglevel string) ApiApiJobRun1Request {
	r.loglevel = &loglevel
	return r
}

// specifies a username identifying the user who ran the job. Requires &#x60;runAs&#x60; permission.
func (r ApiApiJobRun1Request) AsUser(asUser string) ApiApiJobRun1Request {
	r.asUser = &asUser
	return r
}

// can be a node filter string.
func (r ApiApiJobRun1Request) Filter(filter string) ApiApiJobRun1Request {
	r.filter = &filter
	return r
}

// Specify a time to run the job (Since: v18).  This is a ISO-8601 date and time stamp with timezone, with optional milliseconds., e.g. &#x60;2016-11-23T12:20:55-0800&#x60; or &#x60;2016-11-23T12:20:55.123-0800&#x60;
func (r ApiApiJobRun1Request) RunAtTime(runAtTime time.Time) ApiApiJobRun1Request {
	r.runAtTime = &runAtTime
	return r
}

// Option value for option named &#x60;OPTNAME&#x60;. If any &#x60;option.OPTNAME&#x60; parameters are specified, the &#x60;argString&#x60; value is ignored (Since: v18).
func (r ApiApiJobRun1Request) OptionOPTNAME(optionOPTNAME string) ApiApiJobRun1Request {
	r.optionOPTNAME = &optionOPTNAME
	return r
}

// Additional metadata keyd by &#x60;KEY&#x60;. (Since: v32).
func (r ApiApiJobRun1Request) MetaKEY(metaKEY string) ApiApiJobRun1Request {
	r.metaKEY = &metaKEY
	return r
}

// Parameters can be specified in the request body, instead of as query parameters.  (**API v18** or later): The &#x60;options&#x60; entry can contain a map of option name -&gt; value, in which case the &#x60;argString&#x60; is ignored.
func (r ApiApiJobRun1Request) Body(body map[string]interface{}) ApiApiJobRun1Request {
	r.body = &body
	return r
}

func (r ApiApiJobRun1Request) Execute() (*http.Response, error) {
	return r.ApiService.ApiJobRun1Execute(r)
}

/*
ApiJobRun1 Running a Job

Run a job specified by ID.

Parameters can be specified in the request body, instead of as query parameters

Authorization required: `run` for the Job resource.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Job ID
 @return ApiApiJobRun1Request
*/
func (a *JobsAPIService) ApiJobRun1(ctx context.Context, id string) ApiApiJobRun1Request {
	return ApiApiJobRun1Request{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *JobsAPIService) ApiJobRun1Execute(r ApiApiJobRun1Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsAPIService.ApiJobRun1")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/job/{id}/run"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.argString != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "argString", r.argString, "form", "")
	}
	if r.loglevel != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "loglevel", r.loglevel, "form", "")
	}
	if r.asUser != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "asUser", r.asUser, "form", "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "form", "")
	}
	if r.runAtTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "runAtTime", r.runAtTime, "form", "")
	}
	if r.optionOPTNAME != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "option.OPTNAME", r.optionOPTNAME, "form", "")
	}
	if r.metaKEY != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "meta.KEY", r.metaKEY, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["rundeckApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Rundeck-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiJobWorkflowRequest struct {
	ctx context.Context
	ApiService *JobsAPIService
	id string
}

func (r ApiApiJobWorkflowRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ApiJobWorkflowExecute(r)
}

/*
ApiJobWorkflow Get Job Workflow

Get the workflow tree for a job. It will traverse referenced jobs to a depth of 3.

Authorization required: `read` or `view` for the Job.

The authorization level affects the response data.

* `read` - full workflow details are included for each step
* `view` - basic information and description is included for each step

Since: v34

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Job ID
 @return ApiApiJobWorkflowRequest
*/
func (a *JobsAPIService) ApiJobWorkflow(ctx context.Context, id string) ApiApiJobWorkflowRequest {
	return ApiApiJobWorkflowRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *JobsAPIService) ApiJobWorkflowExecute(r ApiApiJobWorkflowRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsAPIService.ApiJobWorkflow")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/job/{id}/workflow"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["rundeckApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Rundeck-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiJobsExportv14Request struct {
	ctx context.Context
	ApiService *JobsAPIService
	project string
	idlist *string
	groupPath *string
	jobFilter *string
	format *string
	jobExactFilter *string
	projFilter *string
	groupPathExact *string
	descFilter *string
	loglevelFilter *string
	scheduledFilter *bool
	scheduleEnabledFilter *bool
	executionEnabledFilter *bool
	serverNodeUUIDFilter *string
	daysAhead *int32
	runJobLaterFilter *bool
	paginatedRequired *bool
}

// A comma-separated list of Job IDs to export
func (r ApiApiJobsExportv14Request) Idlist(idlist string) ApiApiJobsExportv14Request {
	r.idlist = &idlist
	return r
}

// specify a group or partial group path to include all jobs within that group path.
func (r ApiApiJobsExportv14Request) GroupPath(groupPath string) ApiApiJobsExportv14Request {
	r.groupPath = &groupPath
	return r
}

// specify a filter for the job Name
func (r ApiApiJobsExportv14Request) JobFilter(jobFilter string) ApiApiJobsExportv14Request {
	r.jobFilter = &jobFilter
	return r
}

// can be \&quot;yaml\&quot; or \&quot;json\&quot; (API v44+) to specify the output format
func (r ApiApiJobsExportv14Request) Format(format string) ApiApiJobsExportv14Request {
	r.format = &format
	return r
}

func (r ApiApiJobsExportv14Request) JobExactFilter(jobExactFilter string) ApiApiJobsExportv14Request {
	r.jobExactFilter = &jobExactFilter
	return r
}

func (r ApiApiJobsExportv14Request) ProjFilter(projFilter string) ApiApiJobsExportv14Request {
	r.projFilter = &projFilter
	return r
}

func (r ApiApiJobsExportv14Request) GroupPathExact(groupPathExact string) ApiApiJobsExportv14Request {
	r.groupPathExact = &groupPathExact
	return r
}

func (r ApiApiJobsExportv14Request) DescFilter(descFilter string) ApiApiJobsExportv14Request {
	r.descFilter = &descFilter
	return r
}

func (r ApiApiJobsExportv14Request) LoglevelFilter(loglevelFilter string) ApiApiJobsExportv14Request {
	r.loglevelFilter = &loglevelFilter
	return r
}

func (r ApiApiJobsExportv14Request) ScheduledFilter(scheduledFilter bool) ApiApiJobsExportv14Request {
	r.scheduledFilter = &scheduledFilter
	return r
}

func (r ApiApiJobsExportv14Request) ScheduleEnabledFilter(scheduleEnabledFilter bool) ApiApiJobsExportv14Request {
	r.scheduleEnabledFilter = &scheduleEnabledFilter
	return r
}

func (r ApiApiJobsExportv14Request) ExecutionEnabledFilter(executionEnabledFilter bool) ApiApiJobsExportv14Request {
	r.executionEnabledFilter = &executionEnabledFilter
	return r
}

func (r ApiApiJobsExportv14Request) ServerNodeUUIDFilter(serverNodeUUIDFilter string) ApiApiJobsExportv14Request {
	r.serverNodeUUIDFilter = &serverNodeUUIDFilter
	return r
}

func (r ApiApiJobsExportv14Request) DaysAhead(daysAhead int32) ApiApiJobsExportv14Request {
	r.daysAhead = &daysAhead
	return r
}

func (r ApiApiJobsExportv14Request) RunJobLaterFilter(runJobLaterFilter bool) ApiApiJobsExportv14Request {
	r.runJobLaterFilter = &runJobLaterFilter
	return r
}

func (r ApiApiJobsExportv14Request) PaginatedRequired(paginatedRequired bool) ApiApiJobsExportv14Request {
	r.paginatedRequired = &paginatedRequired
	return r
}

func (r ApiApiJobsExportv14Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ApiJobsExportv14Execute(r)
}

/*
ApiJobsExportv14 Export Jobs

Export the job definitions in a Project in JSON or YAML formats.

Authorization required: `read` for each job resource.

Since: v14


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param project Project Name
 @return ApiApiJobsExportv14Request
*/
func (a *JobsAPIService) ApiJobsExportv14(ctx context.Context, project string) ApiApiJobsExportv14Request {
	return ApiApiJobsExportv14Request{
		ApiService: a,
		ctx: ctx,
		project: project,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *JobsAPIService) ApiJobsExportv14Execute(r ApiApiJobsExportv14Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsAPIService.ApiJobsExportv14")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project/{project}/jobs/export"
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.idlist != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idlist", r.idlist, "form", "")
	}
	if r.groupPath != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "groupPath", r.groupPath, "form", "")
	}
	if r.jobFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "jobFilter", r.jobFilter, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "", "")
	}
	if r.jobExactFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "jobExactFilter", r.jobExactFilter, "form", "")
	}
	if r.projFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "projFilter", r.projFilter, "form", "")
	}
	if r.groupPathExact != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "groupPathExact", r.groupPathExact, "form", "")
	}
	if r.descFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "descFilter", r.descFilter, "form", "")
	}
	if r.loglevelFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "loglevelFilter", r.loglevelFilter, "form", "")
	}
	if r.scheduledFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scheduledFilter", r.scheduledFilter, "form", "")
	}
	if r.scheduleEnabledFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scheduleEnabledFilter", r.scheduleEnabledFilter, "form", "")
	}
	if r.executionEnabledFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "executionEnabledFilter", r.executionEnabledFilter, "form", "")
	}
	if r.serverNodeUUIDFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "serverNodeUUIDFilter", r.serverNodeUUIDFilter, "form", "")
	}
	if r.daysAhead != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "daysAhead", r.daysAhead, "form", "")
	}
	if r.runJobLaterFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "runJobLaterFilter", r.runJobLaterFilter, "form", "")
	}
	if r.paginatedRequired != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paginatedRequired", r.paginatedRequired, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/yaml"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["rundeckApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Rundeck-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiJobsImportv14Request struct {
	ctx context.Context
	ApiService *JobsAPIService
	project string
	fileformat *string
	dupeOption *string
	uuidOption *string
}

// Input file format, to specify the input format, if multipart of form input is sent.
func (r ApiApiJobsImportv14Request) Fileformat(fileformat string) ApiApiJobsImportv14Request {
	r.fileformat = &fileformat
	return r
}

// A value to indicate the behavior when importing jobs which already exist.  Value can be \&quot;skip\&quot;, \&quot;create\&quot;, or \&quot;update\&quot;. Default is \&quot;create\&quot;.
func (r ApiApiJobsImportv14Request) DupeOption(dupeOption string) ApiApiJobsImportv14Request {
	r.dupeOption = &dupeOption
	return r
}

// Whether to preserve or remove UUIDs from the imported jobs:  *  &#x60;preserve&#x60;: Preserve the UUIDs in imported jobs.  This may cause the import to fail if the UUID is already used. (Default value). *  &#x60;remove&#x60;: Remove the UUIDs from imported jobs. Allows update/create to succeed without conflict on UUID. 
func (r ApiApiJobsImportv14Request) UuidOption(uuidOption string) ApiApiJobsImportv14Request {
	r.uuidOption = &uuidOption
	return r
}

func (r ApiApiJobsImportv14Request) Execute() (*http.Response, error) {
	return r.ApiService.ApiJobsImportv14Execute(r)
}

/*
ApiJobsImportv14 Import Job definitions

Import a set of job definitions in a supported format.


Since: v14

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param project Project Name
 @return ApiApiJobsImportv14Request
*/
func (a *JobsAPIService) ApiJobsImportv14(ctx context.Context, project string) ApiApiJobsImportv14Request {
	return ApiApiJobsImportv14Request{
		ApiService: a,
		ctx: ctx,
		project: project,
	}
}

// Execute executes the request
func (a *JobsAPIService) ApiJobsImportv14Execute(r ApiApiJobsImportv14Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsAPIService.ApiJobsImportv14")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project/{project}/jobs/import"
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fileformat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fileformat", r.fileformat, "form", "")
	}
	if r.dupeOption != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dupeOption", r.dupeOption, "form", "")
	}
	if r.uuidOption != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "uuidOption", r.uuidOption, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json", "text/yaml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["rundeckApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Rundeck-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 415 {
			var v ApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiJobsImportv14_0Request struct {
	ctx context.Context
	ApiService *JobsAPIService
	project string
	fileformat *string
	dupeOption *string
	uuidOption *string
}

// Input file format, to specify the input format, if multipart of form input is sent.
func (r ApiApiJobsImportv14_0Request) Fileformat(fileformat string) ApiApiJobsImportv14_0Request {
	r.fileformat = &fileformat
	return r
}

// A value to indicate the behavior when importing jobs which already exist.  Value can be \&quot;skip\&quot;, \&quot;create\&quot;, or \&quot;update\&quot;. Default is \&quot;create\&quot;.
func (r ApiApiJobsImportv14_0Request) DupeOption(dupeOption string) ApiApiJobsImportv14_0Request {
	r.dupeOption = &dupeOption
	return r
}

// Whether to preserve or remove UUIDs from the imported jobs:  *  &#x60;preserve&#x60;: Preserve the UUIDs in imported jobs.  This may cause the import to fail if the UUID is already used. (Default value). *  &#x60;remove&#x60;: Remove the UUIDs from imported jobs. Allows update/create to succeed without conflict on UUID. 
func (r ApiApiJobsImportv14_0Request) UuidOption(uuidOption string) ApiApiJobsImportv14_0Request {
	r.uuidOption = &uuidOption
	return r
}

func (r ApiApiJobsImportv14_0Request) Execute() (*http.Response, error) {
	return r.ApiService.ApiJobsImportv14_1Execute(r)
}

/*
ApiJobsImportv14_0 Import Job definitions

Import a set of job definitions in a supported format.


Since: v14

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param project Project Name
 @return ApiApiJobsImportv14_0Request
*/
func (a *JobsAPIService) ApiJobsImportv14_1(ctx context.Context, project string) ApiApiJobsImportv14_0Request {
	return ApiApiJobsImportv14_0Request{
		ApiService: a,
		ctx: ctx,
		project: project,
	}
}

// Execute executes the request
func (a *JobsAPIService) ApiJobsImportv14_1Execute(r ApiApiJobsImportv14_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsAPIService.ApiJobsImportv14_1")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project/{project}/jobs/import"
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fileformat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fileformat", r.fileformat, "form", "")
	}
	if r.dupeOption != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dupeOption", r.dupeOption, "form", "")
	}
	if r.uuidOption != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "uuidOption", r.uuidOption, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded", "multipart/form-data", "application/json", "text/yaml"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["rundeckApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Rundeck-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 415 {
			var v ApiErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiJobsListv2Request struct {
	ctx context.Context
	ApiService *JobsAPIService
	project string
	max *int32
	offset *int32
	tags *int32
	jobFilter *string
	jobExactFilter *string
	projFilter *string
	groupPath *string
	groupPathExact *string
	descFilter *string
	loglevelFilter *string
	idlist *string
	scheduledFilter *bool
	scheduleEnabledFilter *bool
	executionEnabledFilter *bool
	serverNodeUUIDFilter *string
	daysAhead *int32
	runJobLaterFilter *bool
	paginatedRequired *bool
}

// limit the maximum amount of results to be received.
func (r ApiApiJobsListv2Request) Max(max int32) ApiApiJobsListv2Request {
	r.max = &max
	return r
}

// use in conjunction with &#x60;max&#x60; to paginate the result set.
func (r ApiApiJobsListv2Request) Offset(offset int32) ApiApiJobsListv2Request {
	r.offset = &offset
	return r
}

// specify a tag or comma separated list of tags to list Jobs that have matching tags. (e.g. &#x60;tags&#x3D;tag1,tag2&#x60;)
func (r ApiApiJobsListv2Request) Tags(tags int32) ApiApiJobsListv2Request {
	r.tags = &tags
	return r
}

func (r ApiApiJobsListv2Request) JobFilter(jobFilter string) ApiApiJobsListv2Request {
	r.jobFilter = &jobFilter
	return r
}

func (r ApiApiJobsListv2Request) JobExactFilter(jobExactFilter string) ApiApiJobsListv2Request {
	r.jobExactFilter = &jobExactFilter
	return r
}

func (r ApiApiJobsListv2Request) ProjFilter(projFilter string) ApiApiJobsListv2Request {
	r.projFilter = &projFilter
	return r
}

func (r ApiApiJobsListv2Request) GroupPath(groupPath string) ApiApiJobsListv2Request {
	r.groupPath = &groupPath
	return r
}

func (r ApiApiJobsListv2Request) GroupPathExact(groupPathExact string) ApiApiJobsListv2Request {
	r.groupPathExact = &groupPathExact
	return r
}

func (r ApiApiJobsListv2Request) DescFilter(descFilter string) ApiApiJobsListv2Request {
	r.descFilter = &descFilter
	return r
}

func (r ApiApiJobsListv2Request) LoglevelFilter(loglevelFilter string) ApiApiJobsListv2Request {
	r.loglevelFilter = &loglevelFilter
	return r
}

func (r ApiApiJobsListv2Request) Idlist(idlist string) ApiApiJobsListv2Request {
	r.idlist = &idlist
	return r
}

func (r ApiApiJobsListv2Request) ScheduledFilter(scheduledFilter bool) ApiApiJobsListv2Request {
	r.scheduledFilter = &scheduledFilter
	return r
}

func (r ApiApiJobsListv2Request) ScheduleEnabledFilter(scheduleEnabledFilter bool) ApiApiJobsListv2Request {
	r.scheduleEnabledFilter = &scheduleEnabledFilter
	return r
}

func (r ApiApiJobsListv2Request) ExecutionEnabledFilter(executionEnabledFilter bool) ApiApiJobsListv2Request {
	r.executionEnabledFilter = &executionEnabledFilter
	return r
}

func (r ApiApiJobsListv2Request) ServerNodeUUIDFilter(serverNodeUUIDFilter string) ApiApiJobsListv2Request {
	r.serverNodeUUIDFilter = &serverNodeUUIDFilter
	return r
}

func (r ApiApiJobsListv2Request) DaysAhead(daysAhead int32) ApiApiJobsListv2Request {
	r.daysAhead = &daysAhead
	return r
}

func (r ApiApiJobsListv2Request) RunJobLaterFilter(runJobLaterFilter bool) ApiApiJobsListv2Request {
	r.runJobLaterFilter = &runJobLaterFilter
	return r
}

func (r ApiApiJobsListv2Request) PaginatedRequired(paginatedRequired bool) ApiApiJobsListv2Request {
	r.paginatedRequired = &paginatedRequired
	return r
}

func (r ApiApiJobsListv2Request) Execute() ([]JobInfo, *http.Response, error) {
	return r.ApiService.ApiJobsListv2Execute(r)
}

/*
ApiJobsListv2 Listing Jobs

List the jobs that exist for a project.

* `idlist`: specify a comma-separated list of Job IDs to include
* `groupPath`: specify a group or partial group path to include all jobs within that group path. (Default value: "*", all groups). Set to the special value "-" to match the top level jobs only
* `jobFilter`: specify a filter for the job Name. Matches any job name that contains this value.
* `jobExactFilter`: specify an exact job name to match.
* `groupPathExact`: specify an exact group path to match.  Set to the special value "-" to match the top level jobs only
* `scheduledFilter`: `true/false` specify whether to return only scheduled or only not scheduled jobs.
* `serverNodeUUIDFilter`: Value: a UUID. In cluster mode, use to select scheduled jobs assigned to the server with given UUID.

**Note:** It is possible to disable result set pagination by setting the property `rundeck.api.paginatejobs.enabled=false` which is assumed to be true if not set.

**Note:** If neither `groupPath` nor `groupPathExact` are specified, then the default `groupPath` value of "*" will be used (matching jobs in all groups).  `groupPathExact` cannot be combined with `groupPath`.  You can set either one to "-" to match only the top-level jobs which are not within a group.

Authorization required: `view` or `read` for each Job resource.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param project Project Name
 @return ApiApiJobsListv2Request
*/
func (a *JobsAPIService) ApiJobsListv2(ctx context.Context, project string) ApiApiJobsListv2Request {
	return ApiApiJobsListv2Request{
		ApiService: a,
		ctx: ctx,
		project: project,
	}
}

// Execute executes the request
//  @return []JobInfo
func (a *JobsAPIService) ApiJobsListv2Execute(r ApiApiJobsListv2Request) ([]JobInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []JobInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsAPIService.ApiJobsListv2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project/{project}/jobs"
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.max != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max", r.max, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.tags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tags", r.tags, "form", "")
	}
	if r.jobFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "jobFilter", r.jobFilter, "form", "")
	}
	if r.jobExactFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "jobExactFilter", r.jobExactFilter, "form", "")
	}
	if r.projFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "projFilter", r.projFilter, "form", "")
	}
	if r.groupPath != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "groupPath", r.groupPath, "form", "")
	}
	if r.groupPathExact != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "groupPathExact", r.groupPathExact, "form", "")
	}
	if r.descFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "descFilter", r.descFilter, "form", "")
	}
	if r.loglevelFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "loglevelFilter", r.loglevelFilter, "form", "")
	}
	if r.idlist != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "idlist", r.idlist, "form", "")
	}
	if r.scheduledFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scheduledFilter", r.scheduledFilter, "form", "")
	}
	if r.scheduleEnabledFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scheduleEnabledFilter", r.scheduleEnabledFilter, "form", "")
	}
	if r.executionEnabledFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "executionEnabledFilter", r.executionEnabledFilter, "form", "")
	}
	if r.serverNodeUUIDFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "serverNodeUUIDFilter", r.serverNodeUUIDFilter, "form", "")
	}
	if r.daysAhead != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "daysAhead", r.daysAhead, "form", "")
	}
	if r.runJobLaterFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "runJobLaterFilter", r.runJobLaterFilter, "form", "")
	}
	if r.paginatedRequired != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paginatedRequired", r.paginatedRequired, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["rundeckApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Rundeck-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiListAllJobsInProjectRequest struct {
	ctx context.Context
	ApiService *JobsAPIService
	project string
}

func (r ApiApiListAllJobsInProjectRequest) Execute() ([]map[string]interface{}, *http.Response, error) {
	return r.ApiService.ApiListAllJobsInProjectExecute(r)
}

/*
ApiListAllJobsInProject List all Jobs in Summarized Form [Enterprise]

List the jobs summarized for a project.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param project Project Name
 @return ApiApiListAllJobsInProjectRequest
*/
func (a *JobsAPIService) ApiListAllJobsInProject(ctx context.Context, project string) ApiApiListAllJobsInProjectRequest {
	return ApiApiListAllJobsInProjectRequest{
		ApiService: a,
		ctx: ctx,
		project: project,
	}
}

// Execute executes the request
//  @return []map[string]interface{}
func (a *JobsAPIService) ApiListAllJobsInProjectExecute(r ApiApiListAllJobsInProjectRequest) ([]map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsAPIService.ApiListAllJobsInProject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/project/{project}/listAllJobs"
	localVarPath = strings.Replace(localVarPath, "{"+"project"+"}", url.PathEscape(parameterValueToString(r.project, "project")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["rundeckApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Rundeck-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiSchedulerListJobsRequest struct {
	ctx context.Context
	ApiService *JobsAPIService
	uuid string
}

func (r ApiApiSchedulerListJobsRequest) Execute() ([]JobInfo, *http.Response, error) {
	return r.ApiService.ApiSchedulerListJobsExecute(r)
}

/*
ApiSchedulerListJobs List Scheduled Jobs For a Cluster Server

List the scheduled Jobs with their schedule owned by the cluster server with the specified UUID.

Authorization required: `read` or `view` for each job resource

Since: v17

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid Server UUID
 @return ApiApiSchedulerListJobsRequest
*/
func (a *JobsAPIService) ApiSchedulerListJobs(ctx context.Context, uuid string) ApiApiSchedulerListJobsRequest {
	return ApiApiSchedulerListJobsRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return []JobInfo
func (a *JobsAPIService) ApiSchedulerListJobsExecute(r ApiApiSchedulerListJobsRequest) ([]JobInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []JobInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsAPIService.ApiSchedulerListJobs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/scheduler/server/{uuid}/jobs"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterValueToString(r.uuid, "uuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["rundeckApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Rundeck-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiSchedulerListJobsCurrentDocsRequest struct {
	ctx context.Context
	ApiService *JobsAPIService
}

func (r ApiApiSchedulerListJobsCurrentDocsRequest) Execute() ([]JobInfo, *http.Response, error) {
	return r.ApiService.ApiSchedulerListJobsCurrentDocsExecute(r)
}

/*
ApiSchedulerListJobsCurrentDocs List Scheduled Jobs For this Cluster Server

List the scheduled Jobs with their schedule owned by the target cluster server.

Authorization required: `read` or `view` for each job resource

Since: v17

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiSchedulerListJobsCurrentDocsRequest
*/
func (a *JobsAPIService) ApiSchedulerListJobsCurrentDocs(ctx context.Context) ApiApiSchedulerListJobsCurrentDocsRequest {
	return ApiApiSchedulerListJobsCurrentDocsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []JobInfo
func (a *JobsAPIService) ApiSchedulerListJobsCurrentDocsExecute(r ApiApiSchedulerListJobsCurrentDocsRequest) ([]JobInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []JobInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "JobsAPIService.ApiSchedulerListJobsCurrentDocs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/scheduler/jobs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["rundeckApiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Rundeck-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
